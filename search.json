[{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CoevolutionNetworks.html","id":"coevolutionary-analysis","dir":"Articles","previous_headings":"","what":"Coevolutionary Analysis","title":"Building Coevolution Networks with SynExtend","text":"point, ’ve walked steps take set sequences obtain set COGs phylogenetic reconstructions COG. ’re now ready look signals coevolution, imply functional associations COGs. methods implemented via ProtWeaver class SynExtend, includes many commonly used methods detecting coevolutionary patterns. previous steps utilized small subsample data, ’re now finally going work complete dataset. dataset comprised 91 Micrococcus genomes available assemblies Scaffold, Chromosome, Complete level (link query). Note genomes may become available conference; available time. ran complete pipeline identifying annotating genes DECIPHER, finding COGs SynExtend, creating gene trees COG using DECIPHER. complete data consist 3,407 distinct COGs. analysis performed entirely within SynExtend DECIPHER; external packages data required aside input genomes. now use new ProtWeaver class try find COGs show evidence correlated evolutionary selective pressures, also referred ‘coevolutionary signal’.    ton data , unfortunately don’t time look . demonstrate things can ProtWeaver, ’re going look subset data easier investigate. ’ll subset COGs ones meet following characteristics: COGs paralogs COGs part core genome COGs present least 5 genomes (singletons super rare ones) COGs least one high confidence annotation COGs imply coding region relatively arbitrary requirements, subset data example runs quickly easily understandable. essentially takes group COGs essential organisms tend appear lot, characterized individually . Let’s also put together list consensus annotations COG. Now can make ProtWeaver object. ProtWeaver multiple input options, either list formatted like COGs (list gene identifiers) list like CogTrees (list gene trees). ProtWeaver constuctor automatically detects type data adjusts available predictors accordingly. functions best list dendrograms COG, can also run simple presence/absence patterns. See documentation file ProtWeaver information functionality. ’re now ready make predictions. Predicting functional associations done predict.ProtWeaver S3 method. Let’s examine possible functional associations COGs .","code":"library(DECIPHER) library(SynExtend)  COGsFile <- '/path/to/MicrococcusCOGs.RData' AnnotationsFile <- '/path/to/MicrococcusAnnotations.RData' TreesFile <- '/path/to/MicrococcusGeneTrees.RData'  # All of these files are formatted the same way, as lists with each entry # corresponding to a COG. COGs entries are identifiers for each gene, CogsAnnot  # entries are annotations, and CogTrees entries are gene trees load(COGsFile)          # Loads 'COGs' load(AnnotationsFile)   # Loads 'CogsAnnot' load(TreesFile)         # Loads 'CogTrees' # Let's look at one of the COGs COGs[[7]] ##  [1] \"1_1_919\"     \"12_44_1601\"  \"13_5_415\"    \"2_1_10\"      \"14_1_274\"    ##  [6] \"15_1_14\"     \"16_132_1767\" \"17_107_1177\" \"18_1_1825\"   \"19_1_1783\"   ## [11] \"20_1_958\"    \"21_223_1464\" \"22_44_1726\"  \"23_13_736\"   \"3_1_130\"     ## [16] \"24_11_767\"   \"25_1_915\"    \"26_8_258\"    \"27_53_1567\"  \"28_10_1132\"  ## [21] \"29_53_1900\"  \"30_1_72\"     \"31_7_808\"    \"32_7_458\"    \"33_183_1337\" ## [26] \"34_130_2076\" \"35_197_1194\" \"36_128_792\"  \"37_22_1142\"  \"38_81_1984\"  ## [31] \"4_1_9\"       \"39_1_1608\"   \"40_1_416\"    \"41_1_925\"    \"42_1_1032\"   ## [36] \"43_1_707\"    \"44_1_704\"    \"45_13_755\"   \"46_63_1530\"  \"47_1_970\"    ## [41] \"48_1_690\"    \"49_1_779\"    \"50_1_267\"    \"51_20_1253\"  \"52_1_971\"    ## [46] \"53_105_395\"  \"54_109_577\"  \"55_33_1488\"  \"56_11_533\"   \"57_161_2179\" ## [51] \"58_111_515\"  \"59_55_1658\"  \"5_1_9\"       \"60_50_1995\"  \"61_1_78\"     ## [56] \"62_8_204\"    \"63_155_1042\" \"64_47_712\"   \"65_96_2144\"  \"66_11_774\"   ## [61] \"67_66_1831\"  \"68_22_82\"    \"69_22_1206\"  \"70_34_781\"   \"71_96_2235\"  ## [66] \"72_1_1811\"   \"73_11_821\"   \"74_1_221\"    \"75_15_1093\"  \"76_1_2110\"   ## [71] \"77_1_696\"    \"78_1_1963\"   \"79_12_872\"   \"80_12_855\"   \"81_48_2136\"  ## [76] \"82_41_671\"   \"83_20_1289\"  \"84_185_549\"  \"85_42_1351\"  \"86_8_1238\"   ## [81] \"88_7_611\"    \"89_126_1611\" \"90_1_980\"    \"6_21_1244\"   \"7_40_2015\"   ## [86] \"8_1_348\"     \"9_5_575\"     \"10_1_382\"    \"11_1_10\"     \"11_12_1037\"  ## [91] \"91_1_985\" CogsAnnot[[7]] ##   A test set of class 'Taxa' with length 91 ##      confidence name                 taxon ##  [1]       100% 50_1_267             Root; 09120 Genetic Information Processi... ##  [2]       100% 51_20_1253           Root; 09120 Genetic Information Processi... ##  [3]       100% 52_1_971             Root; 09120 Genetic Information Processi... ##  [4]        71% 53_105_395           Root; 09120 Genetic Information Processi... ##  [5]       100% 54_109_577           Root; 09120 Genetic Information Processi... ##  ...        ... ...                  ... ## [87]       100% 45_13_755            Root; 09120 Genetic Information Processi... ## [88]       100% 46_63_1530           Root; 09120 Genetic Information Processi... ## [89]       100% 47_1_970             Root; 09120 Genetic Information Processi... ## [90]       100% 48_1_690             Root; 09120 Genetic Information Processi... ## [91]       100% 49_1_779             Root; 09120 Genetic Information Processi... CogsAnnot[[7]][[1]] ## $taxon ## [1] \"Root\"                                                              ## [2] \"09120 Genetic Information Processing\"                              ## [3] \"09122 Translation\"                                                 ## [4] \"03010 Ribosome [PATH:ko03010]\"                                     ## [5] \"K02899  RP-L27, MRPL27, rpmA, large subunit ribosomal protein L27\" ##  ## $confidence ## [1] 100 100 100 100 100 CogTrees[[7]] ## 'dendrogram' with 2 branches and 91 members total, at height 0.3813559 # Removing leaf labels because they make it hard to read plot(CogTrees[[7]], leaflab='none', main='COG 7') ## Subsetting COGs  # Cutoff values (91 genomes total!) CoreCutoff <- 88 UnderCutoff <- 5  # Get assembly identifiers for each COG truncCOGs <- lapply(COGs, \\(x) sort(as.integer(gsub('^([0-9]+)_.*', '\\\\1', x))))  # Find COGs without paralogs noParas <- sapply(truncCOGs, \\(x) length(x) == length(unique(x)))  # Get non-core genome notCoreCOGs <- sapply(truncCOGs, \\(x) length(unique(x)) < CoreCutoff)  # Get genes in more than 5 organisms notSingles <- sapply(truncCOGs, \\(x) length(unique(x)) > UnderCutoff)  # Make sure COGs are coding elements codingCOGs <- sapply(CogsAnnot, \\(x) is(x, 'Taxa'))  # At least one high confidence annotation highConf <- sapply(CogsAnnot, \\(x)                     if(is(x, 'Taxa'))                       max(sapply(x, \\(y)                                  y$confidence[length(y$confidence)])) > 50                    else FALSE                    )  # Subset for the workshop WorkshopSubset <- noParas & notCoreCOGs & notSingles & codingCOGs & highConf  # Subset our data WCogs <- COGs[WorkshopSubset] WAnnots <- CogsAnnot[WorkshopSubset] WTrees <- CogTrees[WorkshopSubset] # Initialize a character vector to populate consAnnots <- vector('character', length=length(CogsAnnot))  # Loop along the annotations for each COG for ( i in seq_along(CogsAnnot) ){   taxaentry <- CogsAnnot[[i]]      # If no annotation, it's a noncoding gene   if (!is(taxaentry, 'Taxa'))     consAnnots[[i]] <- 'NONCODING'   # Otherwise it's a coding gene   else {     # Grab all the annotations aside from \"Unclassified\"     annots <- sapply(taxaentry, \\(y) y$taxon[length(y$taxon)])     annots <- annots[annots!='unclassified_Root']          # If we only have \"Unclassified\", just mark it as uncharacterized     if (length(annots) == 0)       consAnnots[[i]] <- 'Uncharacterized'          # Otherwise take the most common annotation     else       consAnnots[[i]] <- names(sort(table(annots), decreasing=T))[1]   } } # ProtWeaver constructor pw <- ProtWeaver(WTrees) preds <- predict(pw) print(preds) ## a ProtWeb object. ##  Method used: Ensemble  ##  Number of genes: 88  ##  Number of predictions: 3916"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CoevolutionNetworks.html","id":"viewing-our-results","dir":"Articles","previous_headings":"","what":"Viewing our results","title":"Building Coevolution Networks with SynExtend","text":"Notice preds ProtWeb object. just simple S3 class pretty print method wrapping matrix pairwise association scores. can get raw data GetProtWebData(): ProtWeb class updated next release cycle include methods, including custom plotting function. current plot.ProtWeb S3 method implements force-directed embedding pairwise scores, ’s big work--progress. Stay tuned next release cycle functionality regarding ProtWeb. meantime, can use igraph package find clusters coevolving COGs. Note ’ve identified COGs group associated based coevolutionary pressures, conclusion supported annotation consistency across members group. note clustering done prior knowledge COGs ; reached conclusion using purely sequencing data input. cluster also similar results STRING database. STRING doesn’t nixA, Achl_0397, similar nickle/cobalt transporter. also viral integrase, potentially facilitates HGT genes. conducted analysis hypothetical proteins, inferred novel functions!","code":"# Subset so the output is actually readable GetProtWebData(preds)[1:7, 1:7] ##           116       292       303       323       349       357       457 ## 116 1.0000000 0.2991649 0.2333581 0.2212769 0.2583244 0.2565627 0.1959871 ## 292 0.2991649 1.0000000 0.2474650 0.2811801 0.2310440 0.2988038 0.2406802 ## 303 0.2333581 0.2474650 1.0000000 0.2175542 0.2349209 0.1922557 0.1817777 ## 323 0.2212769 0.2811801 0.2175542 1.0000000 0.2177652 0.2634777 0.1868761 ## 349 0.2583244 0.2310440 0.2349209 0.2177652 1.0000000 0.3468094 0.1798632 ## 357 0.2565627 0.2988038 0.1922557 0.2634777 0.3468094 1.0000000 0.1929837 ## 457 0.1959871 0.2406802 0.1817777 0.1868761 0.1798632 0.1929837 1.0000000 library(igraph) set.seed(1234) # Reproducibility  adjMatrix <- GetProtWebData(preds) g <- graph_from_adjacency_matrix(adjMatrix, weighted=TRUE,                                  mode='undirected', diag=FALSE)  clusters <- cluster_fast_greedy(g)  # Getting the clusters & identifying COGs by consensus annotation clusterLabels <- vector('list', length(clusters)) for ( i in seq_along(clusterLabels) ){   cluster <- communities(clusters)[[i]]   labs <- consAnnots[as.integer(cluster)]   clusterLabels[[i]] <- labs[order(sapply(labs, \\(x) strsplit(x, ' ')[[1]][3]))] }  # Let's examine a cluster clusterLabels[[1]] ## [1] \"K07241  hoxN, nixA, nickel/cobalt transporter (NiCoT) family protein\" ## [2] \"K14059  int, integrase\"                                               ## [3] \"K01430  ureA, urease subunit gamma [EC:3.5.1.5]\"                      ## [4] \"K01429  ureB, urease subunit beta [EC:3.5.1.5]\"                       ## [5] \"K01428  ureC, urease subunit alpha [EC:3.5.1.5]\"                      ## [6] \"K03190  ureD, ureH, urease accessory protein\"                         ## [7] \"K03188  ureF, urease accessory protein\"                               ## [8] \"K03189  ureG, urease accessory protein\""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CoevolutionNetworks.html","id":"methods-implemented-in-protweaver","dir":"Articles","previous_headings":"","what":"Methods Implemented in ProtWeaver","title":"Building Coevolution Networks with SynExtend","text":"default, predict.ProtWeaver makes ensemble prediction using many individual models can run data provided. However, users free use individual models without ensemble predictor. methods implemented following: « 1 2 3 4 5 6 7 »","code":"# PHYLOGENETIC PROFILING METHODS:   ## P/A = Presence/Absence Profiles   ## Jaccard distance of P/A Jaccard <- predict(pw, method='Jaccard')     ## Hamming distance of P/A Hamming <- predict(pw, method='Hamming')     ## MutualInformation of P/A MutualInf <- predict(pw, method='MutualInformation')    ## Direct Coupling Analysis of P/A ProfDCA <- predict(pw, method='ProfDCA')     ## Correlation of gain/loss events on phylogeny, requires Species Tree Behdenna <- predict(pw, method='Behdenna', mySpeciesTree=exSpeciesTree)  # CO-LOCALIZATION METHODS: Colocalization <- predict(pw, method='Coloc') # Co-localization analysis  # DISTANCE MATRIX METHDOS: MirrorTree <- predict(pw, method='MirrorTree') ContextTree <- predict(pw, method='ContextTree')  # Residue Methods: (ONLY AVAILABLE IN DEV VERSION) #   ## MutualInf of residues ResidueMI <- predict(pw, method='ResidueMI')"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"description","dir":"Articles","previous_headings":"","what":"Description","title":"Workshop Overview","text":"workshop consists interactive, instructor-led demonstration common analyses comparative genomics. immediate goal session use sequence data uncover networks functionally associated genes. networks consist genetic regions shared evolutionary pressure, previously shown imply degree conserved function. complete pipeline consists following:  ’ll walk obtaining sequence data, working , identifying genes, finding orthologous regions, creating phylogenetic reconstructions, identifying functional association networks. networks can used make novel hypotheses protein functional pathways. overall purpose workshop slightly broad: teach users utilize wide variety tools computational genomics. Walking pipline serves convenient mechanism guide instruction set broadly applicable tools can easily repurposed many problems. workshop showcase following functionalities hands-tutorials real data: Reading sequence data R Aligning sequences Phylogenetic reconstruction Identifying coding non-coding regions Annotating gene function Finding clusters orthologous genes (COGs) Predicting functional association COGs analyses conducted entirely within R, achievable using raw sequencing data along DECIPHER SynExtend packages. EDIT: Due time constraints, ’re going focus predicting functional associations COGs, time permits can work way backward rest content. Users encouraged read pages later .","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Workshop Overview","text":"DECIPHER SynExtend developed simple possible end user. , pre-requisites workshop following: Basic knowledge R syntax Basic knowledge genomics data (DNA, RNA, amino acids) Participants can expect fully understand entire workshop qualifications. However, users want dig deeper content covered may consider checking DECIPHER website additional tutorials.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"participation","dir":"Articles","previous_headings":"","what":"Participation","title":"Workshop Overview","text":"Attendees expected participate following along examples provided workshop. Rather just listening instruction, attendees expected run examples ask questions related either steps workshop related scenarios methods applicable work.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"bioconductor-packages-used","dir":"Articles","previous_headings":"","what":"Bioconductor packages used","title":"Workshop Overview","text":"DECIPHER SynExtend","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"time-outline","dir":"Articles","previous_headings":"","what":"Time outline","title":"Workshop Overview","text":"Timing estimated may vary depending questions audience.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"workshop-goals-and-objectives","dir":"Articles","previous_headings":"","what":"Workshop goals and objectives","title":"Workshop Overview","text":"“big picture” goal workshop enable researchers conduct computational analyses involving genomics data independently wide variety problems. every attendee need identify co-evolving gene clusters, ability conduct analyses like aligning genomes, creating phylogenetic trees, finding shared selective pressure across genomes valuable researcher molecular biology able quickly analyze preliminary data guide experimental hypotheses. conclusion workshop, attendees possess toolkit analyses can apply data. Computational analyses increasingly valuable modern era microbiology, attendees workshop gain sufficient expertise able conduct basic silico analyses, even don’t deep bioinformatics background.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"learning-goals","dir":"Articles","previous_headings":"","what":"Learning goals","title":"Workshop Overview","text":"Describe work visualize sequencing data R Identify methods analyze evolutionary forces genetic regions Identify orthologous genomic regions Identify annotate gene function","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"learning-objectives","dir":"Articles","previous_headings":"","what":"Learning objectives","title":"Workshop Overview","text":"Analyze sequencing data produce experimental hypotheses Generate phylogenetic reconstructions investigate evolutionary history set genomes Mine big genomic data find regions conserved function across organisms       Get Started!","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Conclusion.html","id":"implementation-at-scale","dir":"Articles","previous_headings":"","what":"Implementation at Scale","title":"Conclusion","text":"analyses designed scalable, yet fast enough able examine thousands genomes within single workshop. Since eventually need make comparisons every pair COGs, task grows quadratically genomes (thus COGs) analyzed. , chose smaller test set showcase performance workshop. However, methods can scale many genomes. methods designed run parallel across supercomputer system. majority methods low CPU memory requirements, thus can run small (2-4GB memory) nodes. recently completed analysis available Streptomyces genomes, can complete little hour given sufficient compute nodes. analytical pipeline looks like :  Users interested deploying analyses scale encouraged contact lab information!","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Conclusion.html","id":"thank-you","dir":"Articles","previous_headings":"","what":"Thank you!","title":"Conclusion","text":"’ve made entire tutorial, thank following along! hope series informative useful analyses. code showcased actively worked members lab, especially ProtWeaver ProtWeb functionalities. comments, suggestions, feature requests ProtWeaver, ProtWeb, tutorial, please feel free either email ahl27@pitt.edu open issue GitHub.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Conclusion.html","id":"other-resources","dir":"Articles","previous_headings":"","what":"Other Resources","title":"Conclusion","text":"’re interested learning , lab, phylogenetics, check resources: website Wright Lab Intro Phylogenetics DECIPHER Tutorials « 1 2 3 4 5 6 7 »","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/ConstructingPhylogenies.html","id":"phylogenetic-reconstruction","dir":"Articles","previous_headings":"","what":"Phylogenetic Reconstruction","title":"Constructing Phylogenies with DECIPHER","text":"’ve now learned find Clusters Orthologous Genes (COGs) set sequences. last thing need final analysis phylogenetic reconstructions gene cluster. step, ’ll build phylogenies COGs using new TreeLine() function introduced latest update DECIPHER. analysis uses third COG previous section (don’t , can download !).    ’s need construct quick phylogenenetic tree R! also set optional argument reconstruct=TRUE TreeLine automatically reconstruct ancestral states node. However, TreeLine incorporates wealth functionality past detailed . fact, tree isn’t even best tree can make! Let’s take look new features included TreeLine() function.","code":"library(DECIPHER)  # This is downloadable using the above button # If you finished the previous page, this is MatchedSequences[[3]] datafile <- '/path/to/testCOG.RData' # Load in example COG  # Again, this is COG 3 from the previous section, which you can get with: # testCOG <- MatchedSequences[[3]]  # If you don't have it, load it in this way load(datafile, verbose=TRUE) # Should load 'testCOG'  # Let's make the names a little more concise # These COGs exist in pairs with two lengths # We'll code them as <Assembly><A/B>, where A is the longer sequence # This renaming will make plotting look a little nicer names(testCOG) <- c('1A', '1B', '2A', '2B',                     '3B', '3A', '4B', '4A',                      '5A', '5B') testCOG <- testCOG[order(names(testCOG))] # Let's look at the aligned COG sequences testCOG ## DNAStringSet object of length 10: ##      width seq                                              names                ##  [1]  1215 GTGTACCTGTCCCACCTCACCGT...CGAGGGCGGCGCCGATGGCTGA 1A ##  [2]   564 ATGGCTGAGACCCCCGCCCCGTT...GCCACGCGACACCTACGGCTGA 1B ##  [3]  1215 GTGTACCTCTCCCACCTCACCGT...CGAGGGCGGCGCCGATGGCTGA 2A ##  [4]   564 ATGGCTGAGACCCCCGCCCCGTT...GCCGCGCGACACCTACGGCTGA 2B ##  [5]  1212 GTGCACCTGTCCCACCTGACCGT...CGGCGCCGGCGGGACCGAGGGT 3A ##  [6]   565 ATGGCTGAGCAGCCCGCCTCGTT...CCCGCGCGACACCTACGGGTGA 3B ##  [7]  1260 GTGCACCTGTCCCACCTCACCGT...GGACGGCGACGCCCGTGCGTGA 4A ##  [8]   597 GTGCGTGAGCGCTCGCCGGAGCC...TCCGCGGGACACCTACGGCTGA 4B ##  [9]  1215 GTGTACCTGTCCCACCTCACCGT...CGAGGGCGGCGCCGATGGCTGA 5A ## [10]   564 ATGGCTGAGACCCCCGCCCCGTT...GCCACGCGACACCTACGGCTGA 5B # Since these are coding regions, AlignTranslation is preferred testSeqs <- AlignTranslation(testCOG)  # Construct a gene tree from aligned sequences treeCOG1 <- TreeLine(testSeqs, method='MP')  # Visualize the result plot(treeCOG1, main='MP')"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/ConstructingPhylogenies.html","id":"tree-building-methods","dir":"Articles","previous_headings":"","what":"Tree-Building Methods","title":"Constructing Phylogenies with DECIPHER","text":"first example used method='MP', meaning constructed phyletic tree using Maximum Parsimony method. However, many methods available. TreeLine() implements Maximum Parsimony (MP), Neighbor-Joining (NJ), Ultrametric (complete, single, UPGMA, WPGMA), Maximum Likelihood (ML) methods. different strengths, weaknesses, assumptions. -depth look difference methods outside scope tutorial, recently published another tutorial goes mathematics methods work. Example code :    Maximum-Likelihood trees accurate, also slowest create. method iteratively maximizes likelihood tree given sequence evolution model set aligned sequences. interest time, demo set maxTime argument prevent algorithm taking long.","code":"# Maximum Parsimony treeMP <- TreeLine(myXStringSet=testSeqs, method='MP', reconstruct=TRUE) plot(treeMP, main='MP') # Neighbor-Joining distMatrix <- DistanceMatrix(testSeqs) treeNJ <- TreeLine(myDistMatrix=distMatrix, method='NJ') plot(treeNJ, main='NJ') # UPGMA tree distMatrix <- DistanceMatrix(testSeqs) treeUltra <- TreeLine(myDistMatrix=distMatrix, method='UPGMA') plot(treeUltra, main='UPGMA') # Maximum Likehood #   - Max runtime is set here to 30sec, default is as long as it takes #   - maxTime expresses time in HOURS, not sec/min #   - Note that method='ML' is the default setting #   - Longer runtime will produce better results treeML <- TreeLine(testSeqs, maxTime=(30/3600)) plot(treeML, main='Maximum-Likelihood')"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/ConstructingPhylogenies.html","id":"sequence-evolution-models","dir":"Articles","previous_headings":"","what":"Sequence Evolution Models","title":"Constructing Phylogenies with DECIPHER","text":"One question ’re probably asking , “‘given sequence evolution model’?” ’s excellent question! default, TreeLine() test variety sequence evolution models pick one works best data. means shouldn’t typically worry model use. However, wanted explicitly pick certain model? wanted exclude handful models? ’re just curious models even tested? Fret , solution. Models passed TreeLine() list two named entries, $Nucleotide $Protein. look default models tested, simply print MODELS variable included DECIPHER: Nucleotide models include classic names like Jukes-Cantor (JC69) Felsenstein 1981 (F81), well many others. amino acid substitution models contain mixture general models (e.g. BLOSUM62, Dayhoff), well models tailored towards specific organisms (e.g. Q.insect, HIVb). use single model, simply create list matching structure MODELS, just models want include. exclude certain models, copy MODELS remove entries don’t want.","code":"DECIPHER::MODELS ## $Nucleotide ##  [1] \"JC69\"     \"JC69+G4\"  \"K80\"      \"K80+G4\"   \"F81\"      \"F81+G4\"   ##  [7] \"HKY85\"    \"HKY85+G4\" \"T92\"      \"T92+G4\"   \"TN93\"     \"TN93+G4\"  ## [13] \"SYM\"      \"SYM+G4\"   \"GTR\"      \"GTR+G4\"   ##  ## $Protein ##  [1] \"AB\"               \"AB+G4\"            \"BLOSUM62\"         \"BLOSUM62+G4\"      ##  [5] \"cpREV\"            \"cpREV+G4\"         \"cpREV64\"          \"cpREV64+G4\"       ##  [9] \"Dayhoff\"          \"Dayhoff+G4\"       \"DCMut-Dayhoff\"    \"DCMut-Dayhoff+G4\" ## [13] \"DCMut-JTT\"        \"DCMut-JTT+G4\"     \"DEN\"              \"DEN+G4\"           ## [17] \"FLAVI\"            \"FLAVI+G4\"         \"FLU\"              \"FLU+G4\"           ## [21] \"gcpREV\"           \"gcpREV+G4\"        \"HIVb\"             \"HIVb+G4\"          ## [25] \"HIVw\"             \"HIVw+G4\"          \"JTT\"              \"JTT+G4\"           ## [29] \"LG\"               \"LG+G4\"            \"MtArt\"            \"MtArt+G4\"         ## [33] \"mtDeu\"            \"mtDeu+G4\"         \"mtInv\"            \"mtInv+G4\"         ## [37] \"mtMam\"            \"mtMam+G4\"         \"mtMet\"            \"mtMet+G4\"         ## [41] \"mtOrt\"            \"mtOrt+G4\"         \"mtREV\"            \"mtREV+G4\"         ## [45] \"mtVer\"            \"mtVer+G4\"         \"MtZoa\"            \"MtZoa+G4\"         ## [49] \"PMB\"              \"PMB+G4\"           \"Q.bird\"           \"Q.bird+G4\"        ## [53] \"Q.insect\"         \"Q.insect+G4\"      \"Q.LG\"             \"Q.LG+G4\"          ## [57] \"Q.mammal\"         \"Q.mammal+G4\"      \"Q.pfam\"           \"Q.pfam+G4\"        ## [61] \"Q.plant\"          \"Q.plant+G4\"       \"Q.yeast\"          \"Q.yeast+G4\"       ## [65] \"rtREV\"            \"rtREV+G4\"         \"stmtREV\"          \"stmtREV+G4\"       ## [69] \"VT\"               \"VT+G4\"            \"WAG\"              \"WAG+G4\"           ## [73] \"WAGstar\"          \"WAGstar+G4\" # Using a specific set of models mySpecificModel <- list(Nucleotide=c('JC69', 'HKY85')) specTree <- TreeLine(testSeqs, model=mySpecificModel, maxTime=(30/3600)) plot(specTree, main='Specific Set ML') # Excluding Specific Models myExcludedModel <- DECIPHER::MODELS myExcludedModel$Protein <- NULL # Remove all protein models myExcludedModel$Nucleotide <- myExcludedModel$Nucleotide[-1] # Remove JC69 exclTree <- TreeLine(testSeqs, model=myExcludedModel, maxTime=(30/3600)) plot(exclTree, main='Excluded Set ML')"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/ConstructingPhylogenies.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Constructing Phylogenies with DECIPHER","text":"’s need know generate phylogenies dataset. order conduct final coevolutionary analysis, ’re going need build gene tree COGs. ’ve precomputed trees us, can load next step without worry long runtimes. parameters didn’t mention writeup. significant one use reconstruct=TRUE, reconstructs ancestral states (important later analyses). also additional arguments multiprocessing (processors=1), using Laguerre quadrature likelihoods (quadrature=T/F), switching type information criterion ML trees (informationCriterion=c('AICc', 'BIC')), many others. See documentation page information –now, ’ll continue final goal. « 1 2 3 4 5 6 7 »","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/FindingCOGs.html","id":"finding-cogs","dir":"Articles","previous_headings":"","what":"Finding COGs","title":"Finding COGs with SynExtend","text":"’ve now learned ways load genomic data R, well ways find annotate genomic sequences. annotated sequence data, ’ll want find genes orthologous. Orthologous genes genes derive common ancestral gene past. can “match” genes different organisms. isn’t guaranteed genes preserved function since diverging ancestral state, give us insight evolution genes time. Sets orthologous genes referred COGs (Clusters Orthologous Genes).","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/FindingCOGs.html","id":"building-our-dataset","dir":"Articles","previous_headings":"","what":"Building Our Dataset","title":"Finding COGs with SynExtend","text":"’re going continue using Micrococcus genomes NCBI, time subset 5 genomes. mentioned previous sections, complete data available , welcome try analyses genomes time! code section work larger datasets, may just wait little . See Conclusions page information running analyses scale. analysis, ’re downloading genomic data .fasta files along precalculated annotations .gff files. also called genes annotated DECIPHER using method previous page, just provides example using prebuilt annotations thorough overview different use cases.  ","code":"library(DECIPHER) library(SynExtend)  COGExampleDir <- '/path/to/uncompressed/micrococcus_wgff' # Using DECIPHER's database API! DBPATH <- tempfile()  # Pull out just the folders we want genomedirs <- list.files(COGExampleDir, full.names = TRUE) genomedirs <- genomedirs[grep('json', genomedirs, fixed=T, invert=T)]  # Initializing our GeneCalls list GeneCalls <- vector('list', length=length(genomedirs))  for (i in seq_along(genomedirs)){   subfiles <- list.files(genomedirs[i], full.names = TRUE)      # Find the FASTA file and the GFF annotations file   fna_file <- subfiles[which(grepl('.*fna$', subfiles))]   gff_file <- subfiles[which(grepl('.*gff$', subfiles))]      # Read in sequence to database   Seqs2DB(seqs = fna_file,           type = \"FASTA\",           dbFile = DBPATH,           identifier = as.character(i), # Sequences must be identified by number           verbose = TRUE)      # Read in annotations   GeneCalls[[i]] <- gffToDataFrame(GFF = gff_file,                                     Verbose = TRUE) } names(GeneCalls) <- seq_along(GeneCalls) # Must have number IDs here too  # Note again that we could have used `FindNonCoding` and `FindGenes` # Rather than rely on having precomputed GeneCalls from a .gff"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/FindingCOGs.html","id":"finding-orthologous-pairs","dir":"Articles","previous_headings":"","what":"Finding Orthologous Pairs","title":"Finding COGs with SynExtend","text":"Now data read successfully. Next, ’ll find pairs orthologous genes. accomplished means NucleotideOverlap() PairSummaries() functions SynExtend. NucleotideOverlap() uses Synteny object determines genomic features connected syntenic hits. PairSummaries determines pairs genes orthologous parsing connected regions. Note: Several methods commented . save time within workshop, since lot cover relatively short time. Running output PairSummaries() BlockExpansion() BlockReconciliation() improves accuracy final identified orthologous regions cost runtime. encourage readers try functionality absence tight time constraints.","code":"Syn <- FindSynteny(dbFile = DBPATH,                    verbose = TRUE)  Overlaps <- NucleotideOverlap(SyntenyObject = Syn,                                GeneCalls = GeneCalls,                                Verbose = TRUE)  Pairs <- PairSummaries(SyntenyLinks = Overlaps,                      GeneCalls = GeneCalls,                      DBPATH = DBPATH,                      PIDs = FALSE, # Set to TRUE for better accuracy (slower)                       Score = FALSE, # Set to TRUE for better accuracy (slower)                      Verbose = TRUE)  # These methods only work if we set PIDs and Score to TRUE # Unfortunately we don't have time in this workshop to use these # Feel free to try them out on your own with a larger dataset!  # P02 <- BlockExpansion(Pairs = P01, #                       DBPATH = DBPATH, #                       Verbose = TRUE, #                       NewPairsOnly = FALSE) # P03 <- BlockReconciliation(Pairs = P02, #                            PIDThreshold = 0.75, #                            SCOREThreshold = 200, #                            Verbose = TRUE) # Pairs <- P03[P03$PID > 0.4, ] head(Pairs) ##      p1       p2 ExactMatch  Consensus TotalKmers MaxKmer p1FeatureLength ## 1 1_1_1 2_1_1997       1464 0.99901164         15     398            1548 ## 2 1_1_2 2_1_1998       1116 1.00000000          1    1116            1116 ## 3 1_1_3 2_1_1999       1143 1.00000000         11     524            1215 ## 4 1_1_4 2_1_1999          8 0.01038438          1       8             564 ## 5 1_1_4 2_1_2000        557 1.00000000          2     540             564 ## 6 1_1_5 2_1_1044        334 0.97322653         11      59            2151 ##   p2FeatureLength Adjacent     TetDist PIDType PredictedPID ## 1            1554        1 0.008090447      AA   0.98276217 ## 2            1116        2 0.000000000      AA   0.99995452 ## 3            1215        1 0.007651500      AA   0.99313621 ## 4            1215        0 0.052066912      AA   0.06709154 ## 5             564        1 0.005041760      AA   0.99717474 ## 6            2106        0 0.026607476      AA   0.55885554"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/FindingCOGs.html","id":"finding-cogs-1","dir":"Articles","previous_headings":"","what":"Finding COGs","title":"Finding COGs with SynExtend","text":"pairwise orthologous regions, can finally determine COGs using DisjointSet() function SynExtend. function analyzes pairs determine orthologs (dis)connected. Future work look smarter ways determine COGs pairwise orthologies, method currently shows strong performance. object list character vectors, element character vector uniquely identifies gene. annotation schema following:  Assembly refers assembly (1-5 data), strand refers chromosome gene found , gene identifier unique number gene. example, 2_1_1999 refers 1999th gene 2nd assembly (genome) 1st chromosome. COGs, can use ExtractBy pull sequences corresponding genomic region COG.","code":"COGSets <- DisjointSet(Pairs = Pairs,                         Verbose = TRUE) COGSets[1:3] ## $`1` ## [1] \"1_1_1\"    \"2_1_1997\" \"3_1_422\"  \"4_1_375\"  \"5_1_1\"    ##  ## $`2` ## [1] \"1_1_2\"    \"2_1_1998\" \"3_1_421\"  \"4_1_374\"  \"5_1_2\"    ##  ## $`3` ##  [1] \"1_1_3\"    \"1_1_4\"    \"2_1_1999\" \"2_1_2000\" \"3_1_419\"  \"3_1_420\"  ##  [7] \"4_1_372\"  \"4_1_373\"  \"5_1_3\"    \"5_1_4\" # Extract sequences for COGs with at least 5 orthologs Sequences <- ExtractBy(x = Pairs,                        y = DBPATH,                        z = COGSets[lengths(COGSets) >= 5],                        Verbose = TRUE)  # These come back in different orders, so let's match them up allnames <- lapply(Sequences, names) COGMapping <- sapply(COGSets, \\(x){                                 which(sapply(allnames, \\(y) setequal(x,y)))                               }                      ) COGMapping <- COGMapping[sapply(COGMapping, \\(x) length(x) > 0)]  MatchedCOGSets <- COGSets[names(COGMapping)] MatchedSequences <- Sequences[unlist(COGMapping)] names(MatchedSequences) <- names(COGMapping) MatchedCOGSets[1:3] ## $`1` ## [1] \"1_1_1\"    \"2_1_1997\" \"3_1_422\"  \"4_1_375\"  \"5_1_1\"    ##  ## $`2` ## [1] \"1_1_2\"    \"2_1_1998\" \"3_1_421\"  \"4_1_374\"  \"5_1_2\"    ##  ## $`3` ##  [1] \"1_1_3\"    \"1_1_4\"    \"2_1_1999\" \"2_1_2000\" \"3_1_419\"  \"3_1_420\"  ##  [7] \"4_1_372\"  \"4_1_373\"  \"5_1_3\"    \"5_1_4\" MatchedSequences[1:3] ## $`1` ## DNAStringSet object of length 5: ##     width seq                                               names                ## [1]  1548 GTGGTGGCAGACCAGGCCGTGCT...AGCGGAAGCAGCGCGGCGCCTGA 1_1_1 ## [2]  1554 GTGGTGGCAGACCAGGCCGTGCT...AGCGGAAACAGCGCGGCGCCTGA 2_1_1997 ## [3]  1551 GTGGTGGCAGACCAGGCCGTGCT...AGCGCAAGCAGCGCGGCGCCTGA 3_1_422 ## [4]  1536 ATGGCGGCGGACCAGGAGCTGCT...AGCGCAAGCAGCGCGGGGCCTGA 4_1_375 ## [5]  1548 GTGGTGGCAGACCAGGCCGTGCT...AGCGGAAGCAGCGCGGCGCCTGA 5_1_1 ##  ## $`2` ## DNAStringSet object of length 5: ##     width seq                                               names                ## [1]  1116 GTGAAGTTCACCGTCGAACGCGA...TGATGCCGGTGCGCATCGCCTGA 1_1_2 ## [2]  1116 GTGAAGTTCACCGTCGAACGCGA...TGATGCCGGTGCGCATCGCCTGA 2_1_1998 ## [3]  1115 GTGAAGTTCACCGTCGAACGCGA...TGATGCCGGTGCGCATCGCCTGA 3_1_421 ## [4]  1116 GTGAAGTTCACCGTGGCACGCGA...TGATGCCCGTCCGCCTGACCTGA 4_1_374 ## [5]  1116 GTGAAGTTCACCGTCGAACGCGA...TGATGCCGGTGCGCATCGCCTGA 5_1_2 ##  ## $`3` ## DNAStringSet object of length 10: ##      width seq                                              names                ##  [1]  1215 GTGTACCTGTCCCACCTCACCGT...CGAGGGCGGCGCCGATGGCTGA 1_1_3 ##  [2]   564 ATGGCTGAGACCCCCGCCCCGTT...GCCACGCGACACCTACGGCTGA 1_1_4 ##  [3]  1215 GTGTACCTCTCCCACCTCACCGT...CGAGGGCGGCGCCGATGGCTGA 2_1_1999 ##  [4]   564 ATGGCTGAGACCCCCGCCCCGTT...GCCGCGCGACACCTACGGCTGA 2_1_2000 ##  [5]   565 ATGGCTGAGCAGCCCGCCTCGTT...CCCGCGCGACACCTACGGGTGA 3_1_419 ##  [6]  1212 GTGCACCTGTCCCACCTGACCGT...CGGCGCCGGCGGGACCGAGGGT 3_1_420 ##  [7]   597 GTGCGTGAGCGCTCGCCGGAGCC...TCCGCGGGACACCTACGGCTGA 4_1_372 ##  [8]  1260 GTGCACCTGTCCCACCTCACCGT...GGACGGCGACGCCCGTGCGTGA 4_1_373 ##  [9]  1215 GTGTACCTGTCCCACCTCACCGT...CGAGGGCGGCGCCGATGGCTGA 5_1_3 ## [10]   564 ATGGCTGAGACCCCCGCCCCGTT...GCCACGCGACACCTACGGCTGA 5_1_4"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/FindingCOGs.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Finding COGs with SynExtend","text":"Now know generate COGs dataset genomes gene calls. also generated gene calls , high quality gene annotations already available (e.g. NCBI), makes sense use . Remember example intentionally small can fit workshop within time constraints–highly encourage experimenting , larger datasets! « 1 2 3 4 5 6 7 »","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/GeneCallingAnnotation.html","id":"gene-calling-and-annotation","dir":"Articles","previous_headings":"","what":"Gene Calling and Annotation","title":"Gene Calling and Annotation with DECIPHER","text":"point, ’ve learned read genomic data, gained basic familiarity working . next step pipeline take set genomes, identify coding regions , predict function many genetic regions can. ’ll start identifying genes .","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/GeneCallingAnnotation.html","id":"finding-genes","dir":"Articles","previous_headings":"","what":"Finding Genes","title":"Gene Calling and Annotation with DECIPHER","text":"’re going keep using Micrococcus dataset, interest time ’ll focus finding genes single sequence. ’ll begin reading data .fasta file, previous section.   Next, ’re going identify genes sequence using FindGenes() DECIPHER package. FindGenes() returns Genes object information genes start end genome. can extract sequences corresponding gene ExtractGenes(). note FindGenes() assumes introns frame shifts, result performs best prokaryotic genomes.","code":"library(DECIPHER)  # This file is downloadable at the above link datafile <- '/path/to/SingleSeq.fa.gz' dnaGenome <- readDNAStringSet(datafile) aaGenome <- translate(dnaGenome) geneLocs <- FindGenes(dnaGenome) # `Genes` object geneLocs ## Genes object of size 2,216 specifying: ## 2,216 protein coding genes from 75 to 4,653 nucleotides. ##  ##   Index Strand Begin   End TotalScore ... Gene ## 1     1      0   256  1803     365.58 ...    1 ## 2     1      0  2554  3669     255.32 ...    1 ## 3     1      0  3691  4905     226.60 ...    1 ## 4     1      0  4898  5461      75.58 ...    1 ## 5     1      0  5819  7981     543.68 ...    1 ## 6     1      0  8050 10746     682.32 ...    1 ## ... with 2,210 more rows. genes <- ExtractGenes(geneLocs, dnaGenome, type='AAStringSet') # Sequences corresponding to each gene genes ## AAStringSet object of length 2216: ##        width seq ##    [1]   516 MVADQAVLSSWRSVVGSLEDDARVSARLMGFV...RKIRELMAERRTIYNQVTELTNEIKRKQRGA* ##    [2]   372 MKFTVERDILTDAVSWAARSLSPRPPVPVLSG...SAPKPALLTGVNQEDGVVSDYRYLVMPVRIA* ##    [3]   405 MYLSHLTVADFRSYRWADLELTPGSTVLLGAN...RQDAEGSEAVAAAAPVEGDIREPRREGGADG* ##    [4]   188 MAETPAPFEPDRPDLALVQLRRVREAARERGE...TRIEVAGPQAPSWRKGPRTVRGGRGPRDTYG* ##    [5]   721 MVDAMPENPAEEPTAASAAPNPEAVPDAVGQP...DAVFSMLMGEDVESRRTFIQQNAKDIRFLDV* ##    ...   ... ... ## [2212]   195 MSAENVTPAPEAEDAVVETPAGQGSRVAEQDD...KIVHDVVADAGLTSESEGEGARRHVVISADD* ## [2213]   333 MFEAILSPFRWLMSWLLGAFHSILEFAGLPAD...QAGRGGAVLNGEVVRQSGQRVQPQRKNRRRK* ## [2214]   123 MTVTPSPFVVLEPSREWGPLRALPSALLAGLL...PPGHRRWPPGRQPRILALNHPPIPPDLPQED* ## [2215]   133 MLPRDRRVRTPAEFRHLGRTGTRAGRRTVVVS...AEADYALLRRETVGALGKALKPHLPAASEHA* ## [2216]    46 MTKRTFQPNNRRRARKHGFRARMRTRAGRAILSARRGKNRAELSA*"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/GeneCallingAnnotation.html","id":"removing-non-coding-regions","dir":"Articles","previous_headings":"","what":"Removing Non-Coding Regions","title":"Gene Calling and Annotation with DECIPHER","text":"FindGenes() finds genes, may coding non-coding genes. ’re interested regions actually translated proteins, since ’ll try annotate later. FindNonCoding() function developed specifically purpose, help distinguish coding non-coding genes. Using FindGenes() FindNonCoding() way also greatly improves accuracy FindGenes(), since won’t accidentally misidentify coding genes non-coding genes. FindNonCoding() used three main datafiles depending data analyze: data(\"NonCodingRNA_Archaea\") Archaeal data data(\"NonCodingRNA_Bacteria\") Bacterial data data(\"NonCodingRNA_Eukarya\") Eukaryotic data include pretrained models common non-coding patterns relevant domain life. pretrained models insuffient, can train dataset using LearnNonCoding(), though outside scope workshop. FindNonCoding() returns Genes object identifying non-coding regions annotations. can pass object FindGenes() improve identification coding regions, resulting accurate gene calling just running FindGenes() directly. , can pull sequences regions using ExtractGenes(). Since coding regions, ’ll also translate amino acids.","code":"data(\"NonCodingRNA_Bacteria\") ncRNA <- NonCodingRNA_Bacteria  geneticRegions <- FindNonCoding(ncRNA, dnaGenome)  ## Find annotations of noncoding regions annotations <- attr(geneticRegions, \"annotations\") geneMatches <- match(geneticRegions[,\"Gene\"], annotations) noncodingAnnots <- sort(table(names(annotations)[geneMatches])) # What noncoding regions have we found and annotated? noncodingAnnots ##  ##            5'_ureB-RF02514            Flavo_1-RF01705  ##                          1                          1  ##     FMN_Riboswitch-RF00050 Glycine_Riboswitch-RF00504  ##                          1                          1  ##    RNase_P_class_A-RF00010           SmallSRP-RF00169  ##                          1                          1  ##              tmRNA-RF00023                   tRNA-Asn  ##                          1                          1  ##                   tRNA-Asp                   tRNA-Cys  ##                          1                          1  ##                   tRNA-His                   tRNA-Phe  ##                          1                          1  ##                   tRNA-Trp                   tRNA-Tyr  ##                          1                          1  ##           rRNA_16S-RF00177           rRNA_23S-RF02541  ##                          2                          2  ##            rRNA_5S-RF00001     SAM_Riboswitch-RF00162  ##                          2                          2  ##     TPP_Riboswitch-RF00059                   tRNA-Gln  ##                          2                          2  ##                   tRNA-Lys                   tRNA-Met  ##                          2                          2  ##                   tRNA-Val                   tRNA-Glu  ##                          2                          3  ##                   tRNA-Ile                   tRNA-Pro  ##                          3                          3  ##                   tRNA-Thr                   tRNA-Ala  ##                          3                          4  ##                   tRNA-Arg                   tRNA-Gly  ##                          4                          4  ##                   tRNA-Ser                   tRNA-Leu  ##                          4                          5 # Find Genes genes <- FindGenes(dnaGenome, includeGenes=geneticRegions) # Genes in the genome genes ## Genes object of size 2,276 specifying: ## 2,218 protein coding genes from 75 to 4,653 nucleotides. ## 58 non-coding RNAs from 73 to 3,088 nucleotides. ##  ##   Index Strand Begin   End TotalScore ... Gene ## 1     1      0   256  1803     365.90 ...    1 ## 2     1      0  2554  3669     254.37 ...    1 ## 3     1      0  3691  4905     227.30 ...    1 ## 4     1      0  4898  5461      75.91 ...    1 ## 5     1      0  5819  7981     544.45 ...    1 ## 6     1      0  8050 10746     682.92 ...    1 ## ... with 2,270 more rows. # Find amino acid sequences corresponding to found genes geneSeqs <- ExtractGenes(genes, dnaGenome, type=\"DNAStringSet\") geneSeqs <- translate(geneSeqs) geneSeqs ## AAStringSet object of length 2276: ##        width seq ##    [1]   516 VVADQAVLSSWRSVVGSLEDDARVSARLMGFV...RKIRELMAERRTIYNQVTELTNEIKRKQRGA* ##    [2]   372 VKFTVERDILTDAVSWAARSLSPRPPVPVLSG...SAPKPALLTGVNQEDGVVSDYRYLVMPVRIA* ##    [3]   405 VYLSHLTVADFRSYRWADLELTPGSTVLLGAN...RQDAEGSEAVAAAAPVEGDIREPRREGGADG* ##    [4]   188 MAETPAPFEPDRPDLALVQLRRVREAARERGE...TRIEVAGPQAPSWRKGPRTVRGGRGPRDTYG* ##    [5]   721 VVDAMPENPAEEPTAASAAPNPEAVPDAVGQP...DAVFSMLMGEDVESRRTFIQQNAKDIRFLDV* ##    ...   ... ... ## [2272]   195 MSAENVTPAPEAEDAVVETPAGQGSRVAEQDD...KIVHDVVADAGLTSESEGEGARRHVVISADD* ## [2273]   333 MFEAILSPFRWLMSWLLGAFHSILEFAGLPAD...QAGRGGAVLNGEVVRQSGQRVQPQRKNRRRK* ## [2274]   123 MTVTPSPFVVLEPSREWGPLRALPSALLAGLL...PPGHRRWPPGRQPRILALNHPPIPPDLPQED* ## [2275]   133 VLPRDRRVRTPAEFRHLGRTGTRAGRRTVVVS...AEADYALLRRETVGALGKALKPHLPAASEHA* ## [2276]    46 VTKRTFQPNNRRRARKHGFRARMRTRAGRAILSARRGKNRAELSA*"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/GeneCallingAnnotation.html","id":"classification-with-idtaxa","dir":"Articles","previous_headings":"","what":"Classification with IDTAXA","title":"Gene Calling and Annotation with DECIPHER","text":"now set coding regions. last step section try annotate function. functionality done IdTaxa() DECIPHER package. IdTaxa() requires training set, can obtained two ways. first download DECIPHER’s downloads page, contains prebuilt training sets variety organisms. ’ll using Actinobacteria dataset obtained website. method build training set using LearnTaxa(). covered workshop, information available DECIPHER documentation people interested. interest time, ’ll just classify first 10 genes. Note training set IdTaxa() trained amino acids, first call translate() DNA sequences able provide IdTaxa() amino acid sequences. Download Training Set   button doesn’t work, can download DECIPHER Downloads Page “Training sets functional classification (amino acids)”. correct training set Microccocus KEGG Actinobacteria. ’ve finished calculating, can either view annotations directly, plot taxonomy.","code":"# RData training set file is downloadable from the above button. # You can also download it directly from the DECIPHER website.  load('/path/to/KEGG_Actinobacteria_r95.RData') # loads \"trainingSet\" # Grab the first 10 genes extracted earlier geneSeqSubset <- geneSeqs[1:10]  # Classify our sequences! ids <- IdTaxa(geneSeqSubset, trainingSet) # Looking at all results ids ##   A test set of class 'Taxa' with length 10 ##      confidence taxon ##  [1]       100% Root; 09130 Environmental Information Processing; 09132 Signa... ##  [2]        99% Root; 09120 Genetic Information Processing; 09124 Replication... ##  [3]       100% Root; 09120 Genetic Information Processing; 09124 Replication... ##  [4]        28% Root; unclassified_Root...                                       ##  [5]        97% Root; 09180 Brite Hierarchies; 09182 Protein families: geneti... ##  [6]       100% Root; 09180 Brite Hierarchies; 09182 Protein families: geneti... ##  [7]        35% Root; unclassified_Root...                                       ##  [8]        66% Root; 09130 Environmental Information Processing; 09131 Membr... ##  [9]        42% Root; unclassified_Root...                                       ## [10]        28% Root; unclassified_Root... # Looking at a specific entry ids[[1]] ## $taxon ## [1] \"Root\"                                                    ## [2] \"09130 Environmental Information Processing\"              ## [3] \"09132 Signal transduction\"                               ## [4] \"02020 Two-component system [PATH:ko02020]\"               ## [5] \"K02313  dnaA, chromosomal replication initiator protein\" ##  ## $confidence ## [1] 100 100 100 100 100 # Plot the distribution of results plot(ids, trainingSet)"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/GeneCallingAnnotation.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Gene Calling and Annotation with DECIPHER","text":"now way identify genomic regions annotate function. However, comparative genomics need way compare genes across organisms can draw conclusions scale. next section, ’ll build techniques find orthologous genomic regions. « 1 2 3 4 5 6 7 »","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/LoadingGenomeData.html","id":"reading-in-sequencing-data","dir":"Articles","previous_headings":"","what":"Reading in Sequencing Data","title":"Loading in Genome Data with DECIPHER","text":"order work sequencing data, first get R format allows us work . commonly used formats genomic data XString XStringSet classes, available Biostrings package. XStrings come four distinct flavors, depending characters allowed: DNAString, DNA data (ATGC, plus gaps ambiguity codes) RNAString, RNA data (AUGC, plus gaps ambiguity codes) AAString, amino acid data (20 amino acids plus U, O, ambiguity codes, unknown/gaps) BString, combination letters XString objects type combined, become XStringSet. provides easy way store work genomics data. example manually creating XStringSet: can also translate DNA sequences amino acid counterparts translate(). Manually typing sequences obviously isn’t great system. Modern sequencing data typically .fasta .fastq file format, let’s look realistic use-case reads data .fasta. ’re going using example Micrococcus genomes obtained NCBI GenBank. purposes workshop, ’ve reduced dataset single Micrococcus gene. expedites examples allow quick processing. sequences packaged single .FASTA file (compressed .fa.gz file), can download button. gene uniquely identified three number code detailed Finding COGs page.   Success! Now large example dataset work . wanted visualize sequences, can open web browser using BrowseSeqs() DECIPHER:","code":"library(DECIPHER) # Auto-imports Biostrings # Making some toy sequences sequences <- c('AGACTCGCA',                'AGACGGTCA',                'TCATTAGTT',                'TGCACAAAA',                'AGCTGTTGC')  sequenceSet <- DNAStringSet(sequences) sequenceSet ## DNAStringSet object of length 5: ##     width seq ## [1]     9 AGACTCGCA ## [2]     9 AGACGGTCA ## [3]     9 TCATTAGTT ## [4]     9 TGCACAAAA ## [5]     9 AGCTGTTGC translate(sequenceSet) ## AAStringSet object of length 5: ##     width seq ## [1]     3 RLA ## [2]     3 RRS ## [3]     3 SLV ## [4]     3 CTK ## [5]     3 SCC # MicroFASTAtrimmed.fa.gz is loaded from the above button # also available at extdata/LoadingData/ within this package  exampleSeqs <- '/path/to/MicroFASTAtrimmed.fa.gz'  exStringSet <- readDNAStringSet(exampleSeqs, format=\"fasta\") # we could also use format='fastq' for FASTQ datasets exStringSet ## DNAStringSet object of length 20: ##      width seq                                              names                ##  [1]   756 TCATCCTGCCAGCGCGGCGCGGG...CAATCGCTGAGGTGTTCGCCAT 13_8_653 ##  [2]   756 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 18_1_1772 ##  [3]   756 TCATCCTGCCAGCGCGGCGCGGG...CAATCGCTGAGGTGTTCGCCAT 27_52_1555 ##  [4]   756 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 29_16_724 ##  [5]   756 TCATCCTGCCAGCGCGGCGCGGG...CAATCGCTGAGGTGTTCGCCAT 30_15_973 ##  ...   ... ... ## [16]   756 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 78_1_1914 ## [17]   756 TCATCCTGCCAGCGCGGCGCGGG...CAATCGCTGAGGTGTTCGCCAT 81_48_2187 ## [18]   756 TCATCCTGCCAGCGCGGCGCGGG...CAATCGCTGAGGTGTTCGCCAT 82_2_146 ## [19]   756 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 90_1_931 ## [20]   756 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 91_1_936 BrowseSeqs(exStringSet)"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/LoadingGenomeData.html","id":"aligning-sequences","dir":"Articles","previous_headings":"","what":"Aligning Sequences","title":"Loading in Genome Data with DECIPHER","text":"Now sequences, let’s explore ways can manipulate . complete demo Biostrings outside scope workshop, ’ll just focus functionality added via DECIPHER. common analysis bioinformatics aligning sequences. easily achievable either AlignSeqs() function AlignTranslation() functions DECIPHER. AlignTranslation() aligns sequences based translated amino acid sequences, significantly accurate coding sequences (like ones ’re working ). Alignments tend start lot gaps, result viewing R isn’t always super informative. , can visualize alignment much better way using BrowseSeqs(): output resemble following:   ","code":"# Align the sequences aliNoTranslate <- AlignSeqs(exStringSet, verbose=FALSE)  # Aligning using translated amino acid sequences # These sequences are coding sequences, so this function will be more accurate aliTranslate <- AlignTranslation(exStringSet, verbose=FALSE)  # Visualize through R  aliTranslate ## DNAStringSet object of length 20: ##      width seq                                              names                ##  [1]   954 -----------------------...---------------------- 13_8_653 ##  [2]   954 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 18_1_1772 ##  [3]   954 -----------------------...---------------------- 27_52_1555 ##  [4]   954 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 29_16_724 ##  [5]   954 -----------------------...---------------------- 30_15_973 ##  ...   ... ... ## [16]   954 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 78_1_1914 ## [17]   954 -----------------------...---------------------- 81_48_2187 ## [18]   954 -----------------------...---------------------- 82_2_146 ## [19]   954 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 90_1_931 ## [20]   954 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 91_1_936 BrowseSeqs(aliTranslate)"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/LoadingGenomeData.html","id":"big-data-with-decipher","dir":"Articles","previous_headings":"","what":"Big Data with DECIPHER","title":"Loading in Genome Data with DECIPHER","text":"One DECIPHER’s unique features ability work massive amounts data. DECIPHER incorporates rich API working sequencing data stored SQLite files. allow users work enormous amounts data (ex. hundreds thousands sequences) providing following benefits: Space optimization Fast random access Concurrent use multiple queries/users Reliable cross-platform storage information benefits using databases DECIPHER, check DECIPHER publication. Setting DECIPHER database takes extra lines code, ’s worth ! Let’s start creating connection SQLite database. Now connection database! used tempfile() temporary file, also added filepath non-temporary file. Note file exist, automatically created. Now ’s time start populating database sequences! done Seqs2DB() following syntax: can also write sequences directly FASTA file database. code, ’re using replaceTbl=TRUE replace table sequences (rather add set twice). Now database, ? start, can run BrowseDB(), function analogous BrowseSeqs() DECIPHER databases. Instead showing sequences, visualization shows entries database can queried.  want read sequences back R XStringSet, use SearchDB(). SearchDB() incorporates far options just returning sequences database. database million sequences, likely crash R environment trying load . Instead, can use following options: ’re done working database, ’s important disconnect open SQLite connections. Many DECIPHER functions use databases rather XStringSet objects speed efficiency. example, let’s look FindSynteny() function. FindSynteny() allows us look syntenic hits sequences without aligning . result allows us easily visualize differences two sequences without computational cost sequence alignment. Let’s look example finding syntenic hits first 6 sequences set.  looking plot? plot compares two genomes, dot syntenic hit two genomes. X position dot location first genome, Y position position second genome. identical genomes, expect see diagonal line \\(y=x\\), indicating bases occur place genomes. Gaps indicate areas match, points diagonal indicate matching areas different places genomes. ’ll see -depth example using Synteny objects returned FindSynteny() later .","code":"# You can set this to any path, use a non-tempfile for long term storage DBPATH <- tempfile() dbConn <- dbConnect(SQLite(), DBPATH) # All sequences must be identified with a unique quantifier # This has to be a character vector; we can make it 1:length(exStringSet) identifiers = as.character(seq_along(exStringSet)) Seqs2DB(seqs=exStringSet, type='XStringSet',          dbFile=dbConn, identifier=identifiers) ## Adding 20 sequences to the database. ##  ## 20 total sequences in table Seqs. ## Time difference of 0.1 secs # We can also directly import from a FASTA file  # FASTA files  Seqs2DB(seqs=exampleSeqs, type='FASTA',          dbFile=dbConn, identifier=identifiers,         replaceTbl=TRUE) ##  Reading FASTA file chunk 1 ##  ## 20 total sequences in table Seqs. ## Time difference of 0.05 secs BrowseDB(dbConn) dbStringSet <- SearchDB(dbConn) ## Search Expression: ## select row_names, sequence from _Seqs where row_names in (select row_names ## from Seqs) ##  ## DNAStringSet of length: 20 ## Time difference of 0 secs dbStringSet ## DNAStringSet object of length 20: ##      width seq                                              names                ##  [1]   756 TCATCCTGCCAGCGCGGCGCGGG...CAATCGCTGAGGTGTTCGCCAT 1 ##  [2]   756 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 2 ##  [3]   756 TCATCCTGCCAGCGCGGCGCGGG...CAATCGCTGAGGTGTTCGCCAT 3 ##  [4]   756 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 4 ##  [5]   756 TCATCCTGCCAGCGCGGCGCGGG...CAATCGCTGAGGTGTTCGCCAT 5 ##  ...   ... ... ## [16]   756 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 16 ## [17]   756 TCATCCTGCCAGCGCGGCGCGGG...CAATCGCTGAGGTGTTCGCCAT 17 ## [18]   756 TCATCCTGCCAGCGCGGCGCGGG...CAATCGCTGAGGTGTTCGCCAT 18 ## [19]   756 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 19 ## [20]   756 ATGGCGAACACCTCAGCGATTGA...CCGCGCCGCGCTGGCAGGATGA 20 # Limit amount returned to first 10 SearchDB(dbConn, limit=10)  # Look for a specific identifier # BrowseDB() is useful here for determining what the identifiers are SearchDB(dbConn, identifier = 'example identifier')  # Run SQL queries #     This clause is appended to the end of a `WHERE ... ` call SearchDB(dbConn, clause = 'identifier in (\"1\", \"2\", \"3\")') dbDisconnect(dbConn) to_select <- c(1,3,5,8) synData <- exStringSet[to_select]  names(synData) <- as.character(to_select)  # Initialize our database DBPATH <- tempfile() dbConn <- dbConnect(SQLite(), DBPATH) Seqs2DB(synData, \"XStringSet\", dbConn, identifier=as.character(to_select))  syn <- FindSynteny(dbConn) dbDisconnect(dbConn)  pairs(syn)"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/LoadingGenomeData.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Loading in Genome Data with DECIPHER","text":"Now ’ve managed read sequence data perform basic analyses. knowledge, can proceed next step pipeline: finding annotating genes. « 1 2 3 4 5 6 7 »","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Setup.html","id":"setting-up-your-environment","dir":"Articles","previous_headings":"","what":"Setting up your environment","title":"Setup","text":"tutorial depends key packages work correctly. page outline install necessary components workshop. ’re attending tutorial Bioconductor 2022, can skip directly next page.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Setup.html","id":"docker-installation","dir":"Articles","previous_headings":"Setting up your environment","what":"Docker Installation","title":"Setup","text":"easiest way run examples tutorial series via Docker. Docker installed, can set environment following command: download relevant Docker container launch RStudio server instance, can access going http://localhost:8787. username default rstudio, password entered <password>. Docker container, can look datafiles/ directory files ’ll need follow along. folder corresponds one tutorial pages site, includes relevant datafiles plus .Rmd file code (don’t copy-paste back forth). Note RStudio Server running Docker currently incompatible ARM Macs, case ’ll use RStudio instance. Bioconductor workshop attendees, ’ll using content CONFERENCE_MATERIALS folder. don’t want use Docker, see .","code":"docker run -e PASSWORD=<password> -p 8787:8787 ghcr.io/ahl27/compgenomicsbioc2022:723220851"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Setup.html","id":"prerequisites","dir":"Articles","previous_headings":"Setting up your environment","what":"Prerequisites","title":"Setup","text":"content shown using R programming language. existing users, note version R must least version 4.x.x compatibility packages ’ll using. also recommend using RStudio development environment, since ’s excellent IDE tons features. step totally optional; feel free use whatever development environment prefer.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Setup.html","id":"installing-packages","dir":"Articles","previous_headings":"Setting up your environment","what":"Installing packages","title":"Setup","text":"workshop depends two main packages: DECIPHER SynExtend. installed via Bioconductor, package manager open source bioinformatics projects R. tutorials use DECIPHER version 2.25.0 SynExtend version 1.9.5, available development version Bioconductor.","code":"if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\")  # Set BiocManager to use development versions BiocManager::install(version='devel')  BiocManager::install('DECIPHER') BiocManager::install('SynExtend')"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Setup.html","id":"downloading-data-optional","dir":"Articles","previous_headings":"Setting up your environment","what":"Downloading Data [Optional]","title":"Setup","text":"interested downloading complete dataset , follow instructions. Note necessary; relevant data part workshop provided subsequent pages. proceed next page, use navbar bottom page. workshop uses set Micrococcus genomes RefSeq annotations assembly levels Scaffold . data included within package, don’t download able follow along! page also contains download links relevant datafiles. ’d like download data , can find genomic data online NCBI’s Genomes Browser. link relevant query pre-filled. can subset dataset just complete genomes using slider bar shown:  ’ve selected relevant genomes, can download “Download Package” button.  options dialog appears, make sure select “RefSeq ” left, “Genome Sequences (FASTA)” right. can optionally select “Annotation Features (GFF)”, though ’ll also cover create annotations workshop.  , download links relevant data section included, need unless really want .         « 1 2 3 4 5 6 7 »","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aidan Lakshman. Author, maintainer.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lakshman (2022). CompGenomicsBioc2022: Comparative Genomics Analyses SynExtend DECIPHER. R package version 3.2.0, https://www.ahl27.com/CompGenomicsBioc2022/.","code":"@Manual{,   title = {CompGenomicsBioc2022: Comparative Genomics Analyses with SynExtend and DECIPHER},   author = {Aidan Lakshman},   year = {2022},   note = {R package version 3.2.0},   url = {https://www.ahl27.com/CompGenomicsBioc2022/}, }"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"using-the-synextend-decipher-pipeline-for-genomic-analysis","dir":"","previous_headings":"","what":"Comparative Genomics with SynExtend and DECIPHER","title":"Comparative Genomics with SynExtend and DECIPHER","text":"SynExtend DECIPHER packages R incorporate wealth easy use functions comparative genomics analyses. interactive tutorial series introduce users packages walking complete workflow identifying co-evolving genes dataset genome sequences. webpage created presentation Bioconductor 2022, content freely available forever. ’ve summarized page skills can expect learn working tutorials site. ’re ready get started, check Overview page!","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"topics-covered","dir":"","previous_headings":"","what":"Topics Covered","title":"Comparative Genomics with SynExtend and DECIPHER","text":" ","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"loading-genome-data-with-decipher","dir":"","previous_headings":"Topics Covered","what":"Loading Genome Data with DECIPHER","title":"Comparative Genomics with SynExtend and DECIPHER","text":"first step analyzing genomics data loading data . download sequencing data NCBI .fasta, load R, perform basic operations data. Users learn efficiently work large scale genomics data, including visualization alignment sequencing data. Function Reference","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"gene-calling-and-annotation-with-decipher","dir":"","previous_headings":"Topics Covered","what":"Gene Calling and Annotation with DECIPHER","title":"Comparative Genomics with SynExtend and DECIPHER","text":"natural next step identifying elements comprise genome dataset. Users learn programmatically identify coding non-coding regions genomes, annotate predicted KEGG orthology groups using IDTAXA. Function Reference","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"annotation-of-cogs-with-synextend","dir":"","previous_headings":"Topics Covered","what":"Annotation of COGs with SynExtend","title":"Comparative Genomics with SynExtend and DECIPHER","text":"Annotated genetic regions can mapped across organisms clusters orthologous genes (COGs). Users learn identify COGs scale using data generated previous step. Function Reference","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"constructing-gene-trees-with-decipher","dir":"","previous_headings":"Topics Covered","what":"Constructing Gene Trees with DECIPHER","title":"Comparative Genomics with SynExtend and DECIPHER","text":"COG comprises sets conserved orthologs across species. data, combined sequencing data ortholog, allow us reconstruct evolutionary history COG. Users learn construct, visualize, save phylogenetic trees sets genomes using TreeLine() function. Function Reference","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"identifying-co-evolving-gene-collectives-with-synextend","dir":"","previous_headings":"Topics Covered","what":"Identifying Co-evolving Gene Collectives with SynExtend","title":"Comparative Genomics with SynExtend and DECIPHER","text":"data, can analyze patterns evolutionary signal across COGs. Co-evolutionary signal genes implies functional association, finding COGs shared selective pressure aids us uncovering mechanisms intracellular pathways. Users learn use ProtWeaver class tease subtle evidence correlated evolutionary pressure order create co-evolutionary networks. Function Reference","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"conclusion","dir":"","previous_headings":"Topics Covered","what":"Conclusion","title":"Comparative Genomics with SynExtend and DECIPHER","text":"working website, users able perform following tasks R: Visualize sequence data Work big genomic data Identify annotate genes sequence data Identify COGs set gene calls Build phylogenies species gene level Analyze shared evolutionary pressure COGs Predict novel protein function coevolutionary signal","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"useful-links","dir":"","previous_headings":"Topics Covered","what":"Useful Links","title":"Comparative Genomics with SynExtend and DECIPHER","text":"DECIPHER SynExtend Related Tutorials Lab!        work licensed Creative Commons Attribution-ShareAlike 4.0 International License.","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-3-2-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 3.2.0","text":"Changes example Loading Genome Data use gene rather random bases Updates images consistency Minor edits formatting","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-3-1-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 3.1.0","text":"Adds information using DECIPHER’s database API working big biological data Switches using base R plots phylogenetics section Removes ape dependency","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-3-0-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 3.0.0","text":"Version bump; code, writing, examples presentation-ready aside possible minor edits download buttons now working Images working Minor formatting fixes","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-2-2-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 2.2.0","text":"Download links fixed IdTaxa training set now download link Images added page","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-2-1-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 2.1.0","text":"ProtWeaver analysis now uses correct dataset Conclusions page updated IdTaxa training set fixed Download links moved page","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"future-work-2-1-0","dir":"Changelog","previous_headings":"","what":"Future Work","title":"Version 2.1.0","text":"download links still missing Conclusions need detail Images missing","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-2-0-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 2.0.0","text":"examples except ProtWeaver analysis use dataset IdTaxa now uses correct training set","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"future-work-2-0-0","dir":"Changelog","previous_headings":"","what":"Future Work","title":"Version 2.0.0","text":"ProtWeaver example updated Conclusions section updated actual takeaways Writeup within section changed reflect new examples Images added","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-1-1-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 1.1.0","text":"Minor updates wording formatting Corrections Gene Calling Annotation page Tutorial section Alignment-Free Analysis removed (readded later figure put )","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-1-0-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 1.0.0","text":"tutorials now complete dataset code!","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"future-work-1-0-0","dir":"Changelog","previous_headings":"","what":"Future Work","title":"Version 1.0.0","text":"Datasets updated prior conference consistency Language/explanations updated May include photo downloading dataset FindingCOGs page","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-0-7-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 0.7.0","text":"Adds download button Setup page datafiles Minor formatting fixes adjustments Examples TreeLine now use correct version","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-0-6-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 0.6.0","text":"Updates GeneCallingAnnotation rough draft code Adds new datafiles use tutorials","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-0-5-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 0.5.0","text":"Updates LoadingGenomeData code Updates ConstructingPhylogenies code Updates CoevolutionNetworks code","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"known-issues-0-5-0","dir":"Changelog","previous_headings":"","what":"Known Issues","title":"Version 0.5.0","text":"Data used code examples neither consisent final Several tutorials still missing code","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"bugfixes-0-4-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"Version 0.4.0","text":"Updated text support pkgdown automatic reference linking Minor updates README","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-0-3-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 0.3.0","text":"Updated tutorials topics covered final product","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"bugfixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"Version 0.2.0","text":"Changes fix display buttons pagination","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-0-1-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 0.1.0","text":"Initialization package Creation several empty files mockup final layout","code":""}]
