[{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CoevolutionNetworks.html","id":"coevolutionary-analysis","dir":"Articles","previous_headings":"","what":"Coevolutionary Analysis","title":"Building Coevolution Networks with SynExtend","text":"point, ’ve walked steps take set sequences obtain set COGs phylogenetic reconstructions COG. ’re now ready look signals coevolution, imply functional associations COGs. methods implemented via ProtWeaver class SynExtend, includes many commonly used methods detecting coevolutionary patterns. previous steps utilized small subsample data, ’re now finally going work complete dataset. dataset comprised 91 Micrococcus genomes available assemblies Scaffold, Chromosome, Complete level (link query). Note genomes may become available conference; available time. ran complete pipeline identifying annotating genes DECIPHER, finding COGs SynExtend, creating gene trees COG using DECIPHER. complete data consist 3,407 distinct COGs. analysis performed entirely within SynExtend DECIPHER; external packages data required aside input genomes. now use new ProtWeaver class try find COGs show evidence correlated evolutionary selective pressures, also referred ‘coevolutionary signal’.   ton data , unfortunately don’t time look . demonstrate things can ProtWeaver, ’re going look subset data easier investigate. ’ll subset COGs ones meet following characteristics: COGs paralogs COGs part core genome COGs present least 5 genomes (singletons super rare ones) COGs least one high confidence annotation COGs imply coding region relatively arbitrary requirements, subset data example runs quickly easily understandable. essentially takes group COGs essential organisms tend appear lot, characterized individually . Let’s also put together list consensus annotations COG. Now can make ProtWeaver object. ProtWeaver multiple input options, either list formatted like COGs (list gene identifiers) list like CogTrees (list gene trees). ProtWeaver constuctor automatically detects type data adjusts available predictors accordingly. functions best list dendrograms COG, can also run simple presence/absence patterns. See documentation file ProtWeaver information functionality. ’re now ready make predictions. Predicting functional associations done predict.ProtWeaver S3 method. Let’s examine possible functional associations COGs .","code":"library(DECIPHER) library(SynExtend)   COGsFile <- '/path/to/MicrococcusCOGs.RData' AnnotationsFile <- '/path/to/MicrococcusAnnotations.RData' TreesFile <- '/path/to/MicrococcusGeneTrees.RData'  # All of these files are formatted the same way, as lists with each entry # corresponding to a COG. COGs entries are identifiers for each gene, CogsAnnot  # entries are annotations, and CogTrees entries are gene trees load(COGsFile)          # Loads 'COGs' load(AnnotationsFile)   # Loads 'CogsAnnot' load(TreesFile)         # Loads 'CogTrees' # Let's look at one of the COGs COGs[[7]] ##  [1] \"1_1_919\"     \"12_44_1601\"  \"13_5_415\"    \"2_1_10\"      \"14_1_274\"    ##  [6] \"15_1_14\"     \"16_132_1767\" \"17_107_1177\" \"18_1_1825\"   \"19_1_1783\"   ## [11] \"20_1_958\"    \"21_223_1464\" \"22_44_1726\"  \"23_13_736\"   \"3_1_130\"     ## [16] \"24_11_767\"   \"25_1_915\"    \"26_8_258\"    \"27_53_1567\"  \"28_10_1132\"  ## [21] \"29_53_1900\"  \"30_1_72\"     \"31_7_808\"    \"32_7_458\"    \"33_183_1337\" ## [26] \"34_130_2076\" \"35_197_1194\" \"36_128_792\"  \"37_22_1142\"  \"38_81_1984\"  ## [31] \"4_1_9\"       \"39_1_1608\"   \"40_1_416\"    \"41_1_925\"    \"42_1_1032\"   ## [36] \"43_1_707\"    \"44_1_704\"    \"45_13_755\"   \"46_63_1530\"  \"47_1_970\"    ## [41] \"48_1_690\"    \"49_1_779\"    \"50_1_267\"    \"51_20_1253\"  \"52_1_971\"    ## [46] \"53_105_395\"  \"54_109_577\"  \"55_33_1488\"  \"56_11_533\"   \"57_161_2179\" ## [51] \"58_111_515\"  \"59_55_1658\"  \"5_1_9\"       \"60_50_1995\"  \"61_1_78\"     ## [56] \"62_8_204\"    \"63_155_1042\" \"64_47_712\"   \"65_96_2144\"  \"66_11_774\"   ## [61] \"67_66_1831\"  \"68_22_82\"    \"69_22_1206\"  \"70_34_781\"   \"71_96_2235\"  ## [66] \"72_1_1811\"   \"73_11_821\"   \"74_1_221\"    \"75_15_1093\"  \"76_1_2110\"   ## [71] \"77_1_696\"    \"78_1_1963\"   \"79_12_872\"   \"80_12_855\"   \"81_48_2136\"  ## [76] \"82_41_671\"   \"83_20_1289\"  \"84_185_549\"  \"85_42_1351\"  \"86_8_1238\"   ## [81] \"88_7_611\"    \"89_126_1611\" \"90_1_980\"    \"6_21_1244\"   \"7_40_2015\"   ## [86] \"8_1_348\"     \"9_5_575\"     \"10_1_382\"    \"11_1_10\"     \"11_12_1037\"  ## [91] \"91_1_985\" CogsAnnot[[7]] ##   A test set of class 'Taxa' with length 91 ##      confidence name                 taxon ##  [1]       100% 50_1_267             Root; 09120 Genetic Information Processi... ##  [2]       100% 51_20_1253           Root; 09120 Genetic Information Processi... ##  [3]       100% 52_1_971             Root; 09120 Genetic Information Processi... ##  [4]        71% 53_105_395           Root; 09120 Genetic Information Processi... ##  [5]       100% 54_109_577           Root; 09120 Genetic Information Processi... ##  ...        ... ...                  ... ## [87]       100% 45_13_755            Root; 09120 Genetic Information Processi... ## [88]       100% 46_63_1530           Root; 09120 Genetic Information Processi... ## [89]       100% 47_1_970             Root; 09120 Genetic Information Processi... ## [90]       100% 48_1_690             Root; 09120 Genetic Information Processi... ## [91]       100% 49_1_779             Root; 09120 Genetic Information Processi... CogsAnnot[[7]][[1]] ## $taxon ## [1] \"Root\"                                                              ## [2] \"09120 Genetic Information Processing\"                              ## [3] \"09122 Translation\"                                                 ## [4] \"03010 Ribosome [PATH:ko03010]\"                                     ## [5] \"K02899  RP-L27, MRPL27, rpmA, large subunit ribosomal protein L27\" ##  ## $confidence ## [1] 100 100 100 100 100 CogTrees[[7]] ## 'dendrogram' with 2 branches and 91 members total, at height 0.3813559 # Note that tree labels correspond to gene identifiers setequal(COGs[[7]], labels(CogTrees[[7]])) ## [1] TRUE ## Subsetting COGs  # Cutoff values (91 genomes total!) CoreCutoff <- 88 UnderCutoff <- 5  # Get assembly identifiers for each COG truncCOGs <- lapply(COGs, \\(x) sort(as.integer(gsub('([0-9]*)_.*', '\\\\1', x))))  # Find COGs without paralogs noParas <- sapply(truncCOGs, \\(x) length(x) == length(unique(x)))  # Get non-core genome notCoreCOGs <- sapply(truncCOGs, \\(x) length(unique(x)) < CoreCutoff)  # Get genes in more than 5 organisms notSingles <- sapply(truncCOGs, \\(x) length(unique(x)) > UnderCutoff)  # Make sure COGs are coding elements codingCOGs <- sapply(CogsAnnot, \\(x) is(x, 'Taxa'))  # At least one high confidence annotation highConf <- sapply(CogsAnnot, \\(x)                     if(is(x, 'Taxa'))                       max(sapply(x, \\(y)                                  y$confidence[length(y$confidence)])) > 50                    else FALSE                    )  # Subset for the workshop WorkshopSubset <- noParas & notCoreCOGs & notSingles & codingCOGs & highConf  # Subset our data WCogs <- COGs[WorkshopSubset] WAnnots <- CogsAnnot[WorkshopSubset] WTrees <- CogTrees[WorkshopSubset] consAnnots <- vector('character', length=length(CogsAnnot)) for ( i in seq_along(CogsAnnot) ){   taxaentry <- CogsAnnot[[i]]   if (!is(taxaentry, 'Taxa'))     consAnnots[[i]] <- 'NONCODING'   else {     annots <- sapply(taxaentry, \\(y) y$taxon[length(y$taxon)])     annots <- annots[annots!='unclassified_Root']     if (length(annots) == 0)       consAnnots[[i]] <- 'PNACT'     else       consAnnots[[i]] <- names(sort(table(annots), decreasing=T))[1]   } }  # Remove this when we get the dev branch of SynExtend consAnnots <- consAnnots[WorkshopSubset] pw <- ProtWeaver(WTrees) preds <- predict(pw) print(preds) ## a ProtWeb object. ##  Method used: Ensemble  ##  Number of genes: 88  ##  Number of predictions: 3916"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CoevolutionNetworks.html","id":"viewing-our-results","dir":"Articles","previous_headings":"","what":"Viewing our results","title":"Building Coevolution Networks with SynExtend","text":"Notice preds ProtWeb object. just simple S3 class pretty print method wrapping matrix pairwise association scores. can get raw data GetProtWebData(): ProtWeb class updated next release cycle include methods, including custom plotting function. current plot.ProtWeb S3 method implements force-directed embedding pairwise scores, ’s big work--progress. Stay tuned next release cycle functionality regarding ProtWeb. meantime, can use igraph package find clusters coevolving COGs. Note ’ve identified COGs group associated based coevolutionary pressures, conclusion supported annotation consistency across members group. note clustering done prior knowledge COGs ; reached conclusion using purely sequencing data input. cluster also similar results STRING database. STRING doesn’t nixA, Achl_0397, similar nickle/cobalt transporter. conducted analysis hypothetical proteins, inferred novel functions!","code":"# Subset so the output is actually readable GetProtWebData(preds)[1:7, 1:7] ##           1         2         3         4         5         6         7 ## 1 1.0000000 0.2991649 0.2026004 0.2212769 0.3039537 0.2565627 0.2318597 ## 2 0.2991649 1.0000000 0.2089901 0.3261475 0.2310440 0.3423066 0.2736087 ## 3 0.2026004 0.2089901 1.0000000 0.2615018 0.1921812 0.2210155 0.1817777 ## 4 0.2212769 0.3261475 0.2615018 1.0000000 0.2177652 0.3018085 0.1868761 ## 5 0.3039537 0.2310440 0.1921812 0.2177652 1.0000000 0.3414119 0.2169666 ## 6 0.2565627 0.3423066 0.2210155 0.3018085 0.3414119 1.0000000 0.1552947 ## 7 0.2318597 0.2736087 0.1817777 0.1868761 0.2169666 0.1552947 1.0000000 library(igraph) # Ensure reproducibility of igraph clustering set.seed(123)  adjMatrix <- GetProtWebData(preds) g <- graph_from_adjacency_matrix(adjMatrix, weighted=TRUE,                                  mode='undirected', diag=FALSE)  clusters <- cluster_fast_greedy(g)  # Getting the clusters & identifying COGs by consensus annotation clusterLabels <- vector('list', length(clusters)) for ( i in seq_along(clusterLabels) ){   cluster <- communities(clusters)[[i]]   labs <- consAnnots[as.integer(cluster)]   clusterLabels[[i]] <- labs[order(sapply(labs, \\(x) strsplit(x, ' ')[[1]][3]))] }  # Let's examine a cluster clusterLabels[[1]] ## [1] \"K07241  hoxN, nixA, nickel/cobalt transporter (NiCoT) family protein\" ## [2] \"K01430  ureA, urease subunit gamma [EC:3.5.1.5]\"                      ## [3] \"K01429  ureB, urease subunit beta [EC:3.5.1.5]\"                       ## [4] \"K01428  ureC, urease subunit alpha [EC:3.5.1.5]\"                      ## [5] \"K03190  ureD, ureH, urease accessory protein\"                         ## [6] \"K03188  ureF, urease accessory protein\"                               ## [7] \"K03189  ureG, urease accessory protein\""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CoevolutionNetworks.html","id":"methods-implemented-in-protweaver","dir":"Articles","previous_headings":"","what":"Methods Implemented in ProtWeaver","title":"Building Coevolution Networks with SynExtend","text":"default, predict.ProtWeaver makes ensemble prediction using many individual models can run data provided. However, users free use individual models without ensemble predictor. methods implemented following: « 1 2 3 4 5 6 7 »","code":"# PHYLOGENETIC PROFILING METHODS:   ## P/A = Presence/Absence Profiles   ## Jaccard distance of P/A Jaccard <- predict(pw, method='Jaccard')     ## Hamming distance of P/A Hamming <- predict(pw, method='Hamming')     ## MutualInformation of P/A MutualInf <- predict(pw, method='MutualInformation')    ## Direct Coupling Analysis of P/A ProfDCA <- predict(pw, method='ProfDCA')     ## Correlation of gain/loss events on phylogeny, requires Species Tree Behdenna <- predict(pw, method='Behdenna', mySpeciesTree=exSpeciesTree)  # CO-LOCALIZATION METHODS: Colocalization <- predict(pw, method='Coloc') # Co-localization analysis  # DISTANCE MATRIX METHDOS: MirrorTree <- predict(pw, method='MirrorTree') ContextTree <- predict(pw, method='ContextTree')  # Residue Methods: (ONLY AVAILABLE IN DEV VERSION) #   ## MutualInf of residues ResidueMI <- predict(pw, method='ResidueMI')"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"comparative-genomics-with-synextend-and-decipher","dir":"Articles","previous_headings":"","what":"Comparative Genomics with SynExtend and DECIPHER","title":"Workshop Overview","text":"Authors: Aidan Lakshman, Nicholas Cooley, Erik S. Wright2.  Last modified: 10 May, 2022.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"description","dir":"Articles","previous_headings":"Comparative Genomics with SynExtend and DECIPHER","what":"Description","title":"Workshop Overview","text":"workshop consists interactive, instructor-led demonstration common analyses comparative genomics. immediate goal session use sequence data uncover networks functionally associated genes. networks consist genetic regions shared evolutionary pressure, previously shown imply degree conserved function. complete pipeline consists following:  ’ll walk obtaining sequence data, working , identifying genes, finding orthologous regions, creating phylogenetic reconstructions, identifying functional association networks. networks can used make novel hypotheses protein functional pathways. analysis useful, overall purpose workshop teach users utilize wide variety tools computational genomics. immediate goal serves convenient mechanism guide instruction set broadly applicable tools can easily repurposed many problems. workshop showcase following functionalities hands-tutorials real data: Reading sequence data R Aligning sequences Phylogenetic reconstruction Identifying coding non-coding regions Annotating gene function Finding clusters orthologous genes (COGs) Predicting functional association COGs analyses conducted entirely within R, achievable using raw sequencing data along DECIPHER SynExtend packages.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"prerequisites","dir":"Articles","previous_headings":"Comparative Genomics with SynExtend and DECIPHER","what":"Prerequisites","title":"Workshop Overview","text":"DECIPHER SynExtend developed simple possible end user. , pre-requisites workshop following: Basic knowledge R syntax Basic knowledge genomics data (DNA, RNA, amino acids) Participants can expect fully understand entire workshop qualifications. However, users want dig deeper content covered may consider checking DECIPHER website additional tutorials.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"participation","dir":"Articles","previous_headings":"Comparative Genomics with SynExtend and DECIPHER","what":"Participation","title":"Workshop Overview","text":"Attendees expected participate following along examples provided workshop. Rather just listening instruction, attendees expected run examples ask questions related either steps workshop related scenarios methods applicable work.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"bioconductor-packages-used","dir":"Articles","previous_headings":"Comparative Genomics with SynExtend and DECIPHER","what":"Bioconductor packages used","title":"Workshop Overview","text":"DECIPHER SynExtend","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"time-outline","dir":"Articles","previous_headings":"Comparative Genomics with SynExtend and DECIPHER","what":"Time outline","title":"Workshop Overview","text":"Timing estimated may vary depending questions audience.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"workshop-goals-and-objectives","dir":"Articles","previous_headings":"Comparative Genomics with SynExtend and DECIPHER","what":"Workshop goals and objectives","title":"Workshop Overview","text":"“big picture” goal workshop enable researchers conduct computational analyses involving genomics data independently wide variety problems. every attendee need identify co-evolving gene clusters, ability conduct analyses like aligning genomes, creating phylogenetic trees, finding shared selective pressure across genomes valuable researcher molecular biology able quickly analyze preliminary data guide experimental hypotheses. conclusion workshop, attendees possess toolkit analyses can apply data. Computational analyses increasingly valuable modern era microbiology, attendees workshop gain sufficient expertise able conduct basic silico analyses, even don’t deep bioinformatics background.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"learning-goals","dir":"Articles","previous_headings":"Comparative Genomics with SynExtend and DECIPHER","what":"Learning goals","title":"Workshop Overview","text":"Describe work visualize sequencing data R Identify methods analyze evolutionary forces genetic regions Identify orthologous genomic regions Identify annotate gene function","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/CompGenomicsBioc2022.html","id":"learning-objectives","dir":"Articles","previous_headings":"Comparative Genomics with SynExtend and DECIPHER","what":"Learning objectives","title":"Workshop Overview","text":"Analyze sequencing data produce experimental hypotheses Generate phylogenetic reconstructions investigate evolutionary history set genomes Mine big genomic data find regions conserved function across organisms       Get Started!","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Conclusion.html","id":"implementation-at-scale","dir":"Articles","previous_headings":"","what":"Implementation at Scale","title":"Conclusion","text":"analyses designed scalable, yet fast enough able examine thousands genomes within single workshop. Since eventually need make comparisons every pair COGs, task grows quadratically genomes (thus COGs) analyzed. , chose smaller test set showcase performance workshop. However, methods can scale many genomes. methods designed run parallel across supercomputer system. majority methods low CPU memory requirements, thus can run small (2-4GB memory) nodes. recently completed analysis available Streptomyces genomes, took approximately three weeks real time executed parallel. Users interested deploying analyses scale encouraged contact lab information!","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Conclusion.html","id":"thank-you","dir":"Articles","previous_headings":"","what":"Thank you!","title":"Conclusion","text":"’ve made entire tutorial, thank following along! hope series informative useful analyses. code showcased actively worked members lab, especially ProtWeaver ProtWeb functionalities. comments, suggestions, feature requests ProtWeaver, ProtWeb, tutorial, please feel free either email ahl27@pitt.edu open issue GitHub.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Conclusion.html","id":"other-resources","dir":"Articles","previous_headings":"","what":"Other Resources","title":"Conclusion","text":"’re interested learning , lab, phylogenetics, check resources: website Wright Lab Intro Phylogenetics DECIPHER Tutorials « 1 2 3 4 5 6 7 »","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/ConstructingPhylogenies.html","id":"phylogenetic-reconstruction","dir":"Articles","previous_headings":"","what":"Phylogenetic Reconstruction","title":"Constructing Phylogenies with DECIPHER","text":"’ve now learned find Clusters Orthologous Genes (COGs) set sequences. last thing need final analysis phylogenetic reconstructions gene cluster. step, ’ll build phylogenies COGs using new TreeLine() function introduced latest update DECIPHER. last step, constructed COGs small subset data learn algorithmic flow portion pipeline. ’ve included precalculated result constructed COGs 91 genomes assembly levels “Scaffold” higher GenBank. section work one COGs. Small note: setup page includes helper function plot phylogenies circular plot. can plot just well plot, just prefer visualization. can also use plottype='unrooted' different visualization, though labels often hard read visualization.    ’s need construct quick phylogenenetic tree R! ’ve set reconstruct=TRUE TreeLine automatically reconstruct ancestral states node. However, TreeLine incorporates wealth functionality past detailed . fact, tree isn’t even best tree can make! Let’s take look new features included TreeLine() function.","code":"library(DECIPHER)  # This is downloadable using the above button datafile <- '/path/to/testCOG.RData' # Load in example COG from the precalculated data load(datafile, verbose=TRUE) # Should load 'testCOG'  # Helper plotting function plot_tree_unrooted <- function(dend, main, plottype='unrooted'){   if(require(ape)){     tf <- tempfile()     WriteDendrogram(dend, file=tf, quoteLabels=FALSE)     predTree <- read.tree(tf)     plot(predTree, plottype, main=main, underscore=TRUE)   } else {     plot(dend, main=main)   } }  # Since these are coding regions, AlignTranslation is preferred testSeqs <- AlignTranslation(testCOG) treeCOG1 <- TreeLine(testSeqs, method='MP', reconstruct=TRUE) # Construct a gene tree plot_tree_unrooted(treeCOG1, main='MP')"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/ConstructingPhylogenies.html","id":"tree-building-methods","dir":"Articles","previous_headings":"","what":"Tree-Building Methods","title":"Constructing Phylogenies with DECIPHER","text":"first example used method='MP', meaning constructed phyletic tree using Maximum Parsimony method. However, many methods available. TreeLine() implements Maximum Parsimony (MP), Neighbor-Joining (NJ), Ultrametric (complete, single, UPGMA, WPGMA), Maximum Likelihood (ML) methods. different strengths, weaknesses, assumptions. -depth look difference methods outside scope tutorial, recently published another tutorial goes mathematics methods work. Example code :    Maximum-Likelihood trees accurate, also slowest create. method iteratively maximizes likelihood tree given sequence evolution model set aligned sequences. interest time, demo set maxTime argument prevent algorithm taking long.","code":"# Maximum Parsimony treeMP <- TreeLine(myXStringSet=testSeqs, method='MP') plot_tree_unrooted(treeMP, main='MP') # Neighbor-Joining distMatrix <- DistanceMatrix(testSeqs, correction='Jukes-Cantor') treeNJ <- TreeLine(myDistMatrix=distMatrix, method='NJ') plot_tree_unrooted(treeNJ, main='NJ') # UPGMA tree distMatrix <- DistanceMatrix(testSeqs, correction='Jukes-Cantor') treeUltra <- TreeLine(myDistMatrix=distMatrix, method='UPGMA') plot(treeUltra, main='UPGMA') # Maximum Likehood #   - Max runtime is set here to 30sec, default is as long as it takes #   - maxTime expresses time in HOURS, not sec/min #   - Note that method='ML' is the default setting #   - Longer runtime will produce better results treeML <- TreeLine(testSeqs, maxTime=(30/3600)) plot_tree_unrooted(treeML, main='Maximum-Likelihood')"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/ConstructingPhylogenies.html","id":"sequence-evolution-models","dir":"Articles","previous_headings":"","what":"Sequence Evolution Models","title":"Constructing Phylogenies with DECIPHER","text":"One question ’re probably asking , “‘given sequence evolution model’?” ’s excellent question! default, TreeLine() test variety sequence evolution models pick one works best data. means shouldn’t typically worry model use. However, wanted explicitly pick certain model? wanted exclude handful models? ’re just curious models even tested? Fret , solution. Models passed TreeLine() list two named entries, $Nucleotide $Protein. look default models tested, simply print MODELS variable included DECIPHER: Nucleotide models include classic names like Jukes-Cantor (JC69) Felsenstein 1981 (F81), well many others. amino acid substitution models contain mixture general models (e.g. BLOSUM62, Dayhoff), well models tailored towards specific organisms (e.g. Q.insect, HIVb). use single model, simply create list matching structure MODELS, just models want include. exclude certain models, copy MODELS remove entries don’t want.","code":"DECIPHER::MODELS ## $Nucleotide ##  [1] \"JC69\"     \"JC69+G4\"  \"K80\"      \"K80+G4\"   \"F81\"      \"F81+G4\"   ##  [7] \"HKY85\"    \"HKY85+G4\" \"T92\"      \"T92+G4\"   \"TN93\"     \"TN93+G4\"  ## [13] \"SYM\"      \"SYM+G4\"   \"GTR\"      \"GTR+G4\"   ##  ## $Protein ##  [1] \"AB\"               \"AB+G4\"            \"BLOSUM62\"         \"BLOSUM62+G4\"      ##  [5] \"cpREV\"            \"cpREV+G4\"         \"cpREV64\"          \"cpREV64+G4\"       ##  [9] \"Dayhoff\"          \"Dayhoff+G4\"       \"DCMut-Dayhoff\"    \"DCMut-Dayhoff+G4\" ## [13] \"DCMut-JTT\"        \"DCMut-JTT+G4\"     \"DEN\"              \"DEN+G4\"           ## [17] \"FLAVI\"            \"FLAVI+G4\"         \"FLU\"              \"FLU+G4\"           ## [21] \"gcpREV\"           \"gcpREV+G4\"        \"HIVb\"             \"HIVb+G4\"          ## [25] \"HIVw\"             \"HIVw+G4\"          \"JTT\"              \"JTT+G4\"           ## [29] \"LG\"               \"LG+G4\"            \"MtArt\"            \"MtArt+G4\"         ## [33] \"mtDeu\"            \"mtDeu+G4\"         \"mtInv\"            \"mtInv+G4\"         ## [37] \"mtMam\"            \"mtMam+G4\"         \"mtMet\"            \"mtMet+G4\"         ## [41] \"mtOrt\"            \"mtOrt+G4\"         \"mtREV\"            \"mtREV+G4\"         ## [45] \"mtVer\"            \"mtVer+G4\"         \"MtZoa\"            \"MtZoa+G4\"         ## [49] \"PMB\"              \"PMB+G4\"           \"Q.bird\"           \"Q.bird+G4\"        ## [53] \"Q.insect\"         \"Q.insect+G4\"      \"Q.LG\"             \"Q.LG+G4\"          ## [57] \"Q.mammal\"         \"Q.mammal+G4\"      \"Q.pfam\"           \"Q.pfam+G4\"        ## [61] \"Q.plant\"          \"Q.plant+G4\"       \"Q.yeast\"          \"Q.yeast+G4\"       ## [65] \"rtREV\"            \"rtREV+G4\"         \"stmtREV\"          \"stmtREV+G4\"       ## [69] \"VT\"               \"VT+G4\"            \"WAG\"              \"WAG+G4\"           ## [73] \"WAGstar\"          \"WAGstar+G4\" # Using a specific set of models mySpecificModel <- list(Nucleotide=c('JC69', 'HKY85')) specTree <- TreeLine(testSeqs, model=mySpecificModel, maxTime=(30/3600)) plot_tree_unrooted(specTree, main='Specific Set ML') # Excluding Specific Models myExcludedModel <- DECIPHER::MODELS myExcludedModel$Protein <- NULL # Remove all protein models myExcludedModel$Nucleotide <- myExcludedModel$Nucleotide[-1] # Remove JC69 exclTree <- TreeLine(testSeqs, model=myExcludedModel, maxTime=(30/3600)) plot_tree_unrooted(exclTree, main='Excluded Set ML')"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/ConstructingPhylogenies.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Constructing Phylogenies with DECIPHER","text":"’s need know generate phylogenies dataset. order conduct final coevolutionary analysis, ’re going need build gene tree COGs. ’ve precomputed trees us, can load next step without worry long runtimes. parameters didn’t mention writeup. significant one use reconstruct=TRUE, reconstructs ancestral states (important later analyses). also additional arguments multiprocessing (processors=1), using Laguerre quadrature likelihoods (quadrature=T/F), switching type information criterion ML trees (informationCriterion=c('AICc', 'BIC')), many others. See documentation page information –now, ’ll continue final goal. « 1 2 3 4 5 6 7 »","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/FindingCOGs.html","id":"finding-cogs","dir":"Articles","previous_headings":"","what":"Finding COGs","title":"Finding COGs with SynExtend","text":"’ve now learned ways load genomic data R, well ways find annotate genomic sequences. annotated sequence data, ’ll want find genes orthologous. Orthologous genes genes derive common ancestral gene past. can “match” genes different organisms. isn’t guaranteed genes preserved function since diverging ancestral state, give us insight evolution genes time. Sets orthologous genes referred COGs (Clusters Orthologous Genes).","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/FindingCOGs.html","id":"building-our-dataset","dir":"Articles","previous_headings":"","what":"Building Our Dataset","title":"Finding COGs with SynExtend","text":"’re going continue using Micrococcus genomes NCBI, time subset 5 genomes. mentioned previous sections, complete data available , welcome try analyses genomes time! code section work larger datasets, may just wait little . See Conclusions page information running analyses scale. analysis, ’re downloading genomic data .fasta files along precalculated annotations .gff files. also called genes annotated DECIPHER using method previous page, just provides example using prebuilt annotations thorough overview different use cases.  ","code":"library(DECIPHER) library(SynExtend)  COGExampleDir <- '/path/to/uncompressed/micrococcus_wgff' # TODO: Better explanation here # We're going to be using the database API for DECIPHER since this is designed for # larger scale analyses. See code below for how we do this! DBPATH <- tempfile()  # Pull out just the folders we want genomedirs <- list.files(COGExampleDir, full.names = TRUE) genomedirs <- genomedirs[grep('json', genomedirs, fixed=T, invert=T)]  # Initializing our GeneCalls list GeneCalls <- vector('list', length=length(genomedirs))  for (i in seq_along(genomedirs)){   subfiles <- list.files(genomedirs[i], full.names = TRUE)      # Find the FASTA file and the GFF annotations file   fna_file <- subfiles[which(grepl('.*fna$', subfiles))]   gff_file <- subfiles[which(grepl('.*gff$', subfiles))]      # Read in sequence to database   Seqs2DB(seqs = fna_file,           type = \"FASTA\",           dbFile = DBPATH,           identifier = as.character(i), # Sequences must be identified by number           verbose = TRUE)      # Read in annotations   GeneCalls[[i]] <- gffToDataFrame(GFF = gff_file,                                     Verbose = TRUE) } names(GeneCalls) <- seq_along(GeneCalls) # Must have number IDs here too  # Note again that we could have used `FindNonCoding` and `FindGenes` # Rather than rely on having precomputed GeneCalls from a .gff"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/FindingCOGs.html","id":"finding-orthologous-pairs","dir":"Articles","previous_headings":"","what":"Finding Orthologous Pairs","title":"Finding COGs with SynExtend","text":"Now data read successfully. Next, ’ll find pairs orthologous genes. accomplished means NucleotideOverlap() PairSummaries() functions SynExtend. NucleotideOverlap() uses Synteny object determines genomic features connected syntenic hits. PairSummaries determines pairs genes orthologous parsing connected regions. Note: Several methods commented . save time within workshop, since lot cover relatively short time. Running output PairSummaries() BlockExpansion() BlockReconciliation() improves accuracy final identified orthologous regions cost runtime. encourage readers try functionality absence tight time constraints.","code":"Syn <- FindSynteny(dbFile = DBPATH,                    verbose = TRUE)  Overlaps <- NucleotideOverlap(SyntenyObject = Syn,                                GeneCalls = GeneCalls,                                Verbose = TRUE)  Pairs <- PairSummaries(SyntenyLinks = Overlaps,                      GeneCalls = GeneCalls,                      DBPATH = DBPATH,                      PIDs = FALSE, # Set to TRUE for better accuracy (slower)                       Score = FALSE, # Set to TRUE for better accuracy (slower)                      Verbose = TRUE)  # These methods only work if we set PIDs and Score to TRUE # Unfortunately we don't have time in this workshop to use these # Feel free to try them out on your own with a larger dataset!  # P02 <- BlockExpansion(Pairs = P01, #                       DBPATH = DBPATH, #                       Verbose = TRUE, #                       NewPairsOnly = FALSE) # P03 <- BlockReconciliation(Pairs = P02, #                            PIDThreshold = 0.75, #                            SCOREThreshold = 200, #                            Verbose = TRUE) # Pairs <- P03[P03$PID > 0.4, ] head(Pairs) ##      p1       p2 ExactMatch  Consensus TotalKmers MaxKmer p1FeatureLength ## 1 1_1_1 2_1_1997       1464 0.99901164         15     398            1548 ## 2 1_1_2 2_1_1998       1116 1.00000000          1    1116            1116 ## 3 1_1_3 2_1_1999       1143 1.00000000         11     524            1215 ## 4 1_1_4 2_1_1999          8 0.01038438          1       8             564 ## 5 1_1_4 2_1_2000        557 1.00000000          2     540             564 ## 6 1_1_5 2_1_1044        334 0.97322653         11      59            2151 ##   p2FeatureLength Adjacent     TetDist PIDType PredictedPID ## 1            1554        1 0.008090447      AA   0.98276217 ## 2            1116        2 0.000000000      AA   0.99995452 ## 3            1215        1 0.007651500      AA   0.99313621 ## 4            1215        0 0.052066912      AA   0.06709154 ## 5             564        1 0.005041760      AA   0.99717474 ## 6            2106        0 0.026607476      AA   0.55885554"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/FindingCOGs.html","id":"finding-cogs-1","dir":"Articles","previous_headings":"","what":"Finding COGs","title":"Finding COGs with SynExtend","text":"pairwise orthologous regions, can finally determine COGs using DisjointSet() function SynExtend. function analyzes pairs determine orthologs (dis)connected. Future work look smarter ways determine COGs pairwise orthologies, method currently shows strong performance. also use ExtractBy pull sequences corresponding genomic region COG.","code":"COGSets <- DisjointSet(Pairs = Pairs,                         Verbose = TRUE)  # Extract sequences for COGs with at least orthologs Sequences <- ExtractBy(x = Pairs,                        y = DBPATH,                        z = COGSets[lengths(COGSets) >= 5],                        Verbose = TRUE)  # These come back in different orders, so let's match them up allnames <- lapply(Sequences, names) COGMapping <- sapply(COGSets, \\(x){                                 which(sapply(allnames, \\(y) setequal(x,y)))                               }                      ) COGMapping <- COGMapping[sapply(COGMapping, \\(x) length(x) > 0)]  MatchedCOGSets <- COGSets[names(COGMapping)] MatchedSequences <- Sequences[unlist(COGMapping)] names(MatchedSequences) <- names(COGMapping) MatchedCOGSets[1:3] ## $`1` ## [1] \"1_1_1\"    \"2_1_1997\" \"3_1_422\"  \"4_1_375\"  \"5_1_1\"    ##  ## $`2` ## [1] \"1_1_2\"    \"2_1_1998\" \"3_1_421\"  \"4_1_374\"  \"5_1_2\"    ##  ## $`3` ##  [1] \"1_1_3\"    \"1_1_4\"    \"2_1_1999\" \"2_1_2000\" \"3_1_419\"  \"3_1_420\"  ##  [7] \"4_1_372\"  \"4_1_373\"  \"5_1_3\"    \"5_1_4\" MatchedSequences[1:3] ## $`1` ## DNAStringSet object of length 5: ##     width seq                                               names                ## [1]  1548 GTGGTGGCAGACCAGGCCGTGCT...AGCGGAAGCAGCGCGGCGCCTGA 1_1_1 ## [2]  1554 GTGGTGGCAGACCAGGCCGTGCT...AGCGGAAACAGCGCGGCGCCTGA 2_1_1997 ## [3]  1551 GTGGTGGCAGACCAGGCCGTGCT...AGCGCAAGCAGCGCGGCGCCTGA 3_1_422 ## [4]  1536 ATGGCGGCGGACCAGGAGCTGCT...AGCGCAAGCAGCGCGGGGCCTGA 4_1_375 ## [5]  1548 GTGGTGGCAGACCAGGCCGTGCT...AGCGGAAGCAGCGCGGCGCCTGA 5_1_1 ##  ## $`2` ## DNAStringSet object of length 5: ##     width seq                                               names                ## [1]  1116 GTGAAGTTCACCGTCGAACGCGA...TGATGCCGGTGCGCATCGCCTGA 1_1_2 ## [2]  1116 GTGAAGTTCACCGTCGAACGCGA...TGATGCCGGTGCGCATCGCCTGA 2_1_1998 ## [3]  1115 GTGAAGTTCACCGTCGAACGCGA...TGATGCCGGTGCGCATCGCCTGA 3_1_421 ## [4]  1116 GTGAAGTTCACCGTGGCACGCGA...TGATGCCCGTCCGCCTGACCTGA 4_1_374 ## [5]  1116 GTGAAGTTCACCGTCGAACGCGA...TGATGCCGGTGCGCATCGCCTGA 5_1_2 ##  ## $`3` ## DNAStringSet object of length 10: ##      width seq                                              names                ##  [1]  1215 GTGTACCTGTCCCACCTCACCGT...CGAGGGCGGCGCCGATGGCTGA 1_1_3 ##  [2]   564 ATGGCTGAGACCCCCGCCCCGTT...GCCACGCGACACCTACGGCTGA 1_1_4 ##  [3]  1215 GTGTACCTCTCCCACCTCACCGT...CGAGGGCGGCGCCGATGGCTGA 2_1_1999 ##  [4]   564 ATGGCTGAGACCCCCGCCCCGTT...GCCGCGCGACACCTACGGCTGA 2_1_2000 ##  [5]   565 ATGGCTGAGCAGCCCGCCTCGTT...CCCGCGCGACACCTACGGGTGA 3_1_419 ##  [6]  1212 GTGCACCTGTCCCACCTGACCGT...CGGCGCCGGCGGGACCGAGGGT 3_1_420 ##  [7]   597 GTGCGTGAGCGCTCGCCGGAGCC...TCCGCGGGACACCTACGGCTGA 4_1_372 ##  [8]  1260 GTGCACCTGTCCCACCTCACCGT...GGACGGCGACGCCCGTGCGTGA 4_1_373 ##  [9]  1215 GTGTACCTGTCCCACCTCACCGT...CGAGGGCGGCGCCGATGGCTGA 5_1_3 ## [10]   564 ATGGCTGAGACCCCCGCCCCGTT...GCCACGCGACACCTACGGCTGA 5_1_4"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/FindingCOGs.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Finding COGs with SynExtend","text":"Now know generate COGs dataset genomes gene calls. also generated gene calls , high quality gene annotations already available (e.g. NCBI), makes sense use . Remember example intentionally small can fit workshop within time constraints–highly encourage experimenting , larger datasets! « 1 2 3 4 5 6 7 »","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/GeneCallingAnnotation.html","id":"gene-calling-and-annotation","dir":"Articles","previous_headings":"","what":"Gene Calling and Annotation","title":"Gene Calling and Annotation with DECIPHER","text":"point, ’ve learned read genomic data, gained basic familiarity working . next step pipeline take set genomes, identify coding regions , predict function many genetic regions can. ’ll start identifying genes .","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/GeneCallingAnnotation.html","id":"finding-genes","dir":"Articles","previous_headings":"","what":"Finding Genes","title":"Gene Calling and Annotation with DECIPHER","text":"’re going keep using Micrococcus dataset, interest time ’ll focus finding genes single sequence. ’ll begin reading data .fasta file, previous section.   Next, ’re going identify genes sequence using FindGenes() DECIPHER package. FindGenes() returns Genes object information genes start end genome. can extract sequences corresponding gene using ExtractGenes() function.","code":"library(DECIPHER)  # This file is downloadable at the above link datafile <- '/path/to/SingleSeq.fa.gz' dnaGenome <- readDNAStringSet(datafile) aaGenome <- translate(dnaGenome) geneLocs <- FindGenes(dnaGenome) genes <- ExtractGenes(geneLocs, dnaGenome, type='AAStringSet') # `Genes` object geneLocs ## Genes object of size 2,216 specifying: ## 2,216 protein coding genes from 75 to 4,653 nucleotides. ##  ##   Index Strand Begin   End TotalScore ... Gene ## 1     1      0   256  1803     366.91 ...    1 ## 2     1      0  2554  3669     255.68 ...    1 ## 3     1      0  3691  4905     227.78 ...    1 ## 4     1      0  4898  5461      75.36 ...    1 ## 5     1      0  5819  7981     546.22 ...    1 ## 6     1      0  8050 10746     685.83 ...    1 ## ... with 2,210 more rows. # Sequences corresponding to each gene genes ## AAStringSet object of length 2216: ##        width seq ##    [1]   516 MVADQAVLSSWRSVVGSLEDDARVSARLMGFV...RKIRELMAERRTIYNQVTELTNEIKRKQRGA* ##    [2]   372 MKFTVERDILTDAVSWAARSLSPRPPVPVLSG...SAPKPALLTGVNQEDGVVSDYRYLVMPVRIA* ##    [3]   405 MYLSHLTVADFRSYRWADLELTPGSTVLLGAN...RQDAEGSEAVAAAAPVEGDIREPRREGGADG* ##    [4]   188 MAETPAPFEPDRPDLALVQLRRVREAARERGE...TRIEVAGPQAPSWRKGPRTVRGGRGPRDTYG* ##    [5]   721 MVDAMPENPAEEPTAASAAPNPEAVPDAVGQP...DAVFSMLMGEDVESRRTFIQQNAKDIRFLDV* ##    ...   ... ... ## [2212]   195 MSAENVTPAPEAEDAVVETPAGQGSRVAEQDD...KIVHDVVADAGLTSESEGEGARRHVVISADD* ## [2213]   333 MFEAILSPFRWLMSWLLGAFHSILEFAGLPAD...QAGRGGAVLNGEVVRQSGQRVQPQRKNRRRK* ## [2214]   123 MTVTPSPFVVLEPSREWGPLRALPSALLAGLL...PPGHRRWPPGRQPRILALNHPPIPPDLPQED* ## [2215]   133 MLPRDRRVRTPAEFRHLGRTGTRAGRRTVVVS...AEADYALLRRETVGALGKALKPHLPAASEHA* ## [2216]    46 MTKRTFQPNNRRRARKHGFRARMRTRAGRAILSARRGKNRAELSA*"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/GeneCallingAnnotation.html","id":"removing-non-coding-regions","dir":"Articles","previous_headings":"","what":"Removing Non-Coding Regions","title":"Gene Calling and Annotation with DECIPHER","text":"FindGenes() finds genes , may include non-coding regions. ’re interested regions actually translated proteins, since ’ll try annotate later. , ’ll use FindNonCoding() function. Using FindGenes() FindNonCoding() way greatly improves accuracy FindGenes(). FindNonCoding() used three main datafiles depending data analyze: data(\"NonCodingRNA_Archaea\") Archaeal data data(\"NonCodingRNA_Bacteria\") Bacterial data data(\"NonCodingRNA_Eukarya\") Eukaryotic data include pretrained models common non-coding patterns relevant domain life. pretrained models insuffient, can train dataset using LearnNonCoding(), though outside scope workshop. ’ve run FindNonCoding(), can use ExtractGenes() pull coding regions. result accurate gene calling just running FindGenes() directly.","code":"data(\"NonCodingRNA_Bacteria\") ncRNA <- NonCodingRNA_Bacteria  geneticRegions <- FindNonCoding(ncRNA, dnaGenome)  ## Find annotations of noncoding regions annotations <- attr(geneticRegions, \"annotations\") geneMatches <- match(geneticRegions[,\"Gene\"], annotations) noncodingAnnots <- sort(table(names(annotations)[geneMatches])) # What noncoding regions have we found and annotated? noncodingAnnots ##  ##            5'_ureB-RF02514            Flavo_1-RF01705  ##                          1                          1  ##     FMN_Riboswitch-RF00050 Glycine_Riboswitch-RF00504  ##                          1                          1  ##    RNase_P_class_A-RF00010           SmallSRP-RF00169  ##                          1                          1  ##              tmRNA-RF00023                   tRNA-Asn  ##                          1                          1  ##                   tRNA-Asp                   tRNA-Cys  ##                          1                          1  ##                   tRNA-His                   tRNA-Phe  ##                          1                          1  ##                   tRNA-Trp                   tRNA-Tyr  ##                          1                          1  ##           rRNA_16S-RF00177           rRNA_23S-RF02541  ##                          2                          2  ##            rRNA_5S-RF00001     SAM_Riboswitch-RF00162  ##                          2                          2  ##     TPP_Riboswitch-RF00059                   tRNA-Gln  ##                          2                          2  ##                   tRNA-Lys                   tRNA-Met  ##                          2                          2  ##                   tRNA-Val                   tRNA-Glu  ##                          2                          3  ##                   tRNA-Ile                   tRNA-Pro  ##                          3                          3  ##                   tRNA-Thr                   tRNA-Ala  ##                          3                          4  ##                   tRNA-Arg                   tRNA-Gly  ##                          4                          4  ##                   tRNA-Ser                   tRNA-Leu  ##                          4                          5 # Find Genes genes <- FindGenes(dnaGenome, includeGenes=geneticRegions) # Genes in the genome genes ## Genes object of size 2,252 specifying: ## 2,194 protein coding genes from 99 to 4,653 nucleotides. ## 58 non-coding RNAs from 73 to 3,088 nucleotides. ##  ##   Index Strand Begin   End TotalScore ... Gene ## 1     1      0   256  1803     375.70 ...    1 ## 2     1      0  2554  3669     262.53 ...    1 ## 3     1      0  3691  4905     225.33 ...    1 ## 4     1      0  4898  5461      71.84 ...    1 ## 5     1      0  5819  7981     557.96 ...    1 ## 6     1      0  8050 10746     694.74 ...    1 ## ... with 2,246 more rows."},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/GeneCallingAnnotation.html","id":"classification-with-idtaxa","dir":"Articles","previous_headings":"","what":"Classification with IDTAXA","title":"Gene Calling and Annotation with DECIPHER","text":"now set coding regions. last step section try annotate function. functionality done IdTaxa() DECIPHER package. IdTaxa() requires training set, can obtained two ways. first download DECIPHER’s downloads page, contains prebuilt training sets variety organisms. ’ll using Actinobacteria dataset obtained website. method build training set using LearnTaxa(). covered workshop, information available DECIPHER documentation people interested. interest time, ’ll just classify first 10 genes. Note training set IdTaxa() trained amino acids, first call translate() DNA sequences able provide IdTaxa() amino acid sequences. Download Training Set   ’ve finished calculating, can either view annotations directly, plot taxonomy.  « 1 2 3 4 5 6 7 »","code":"# RData training set file is downloadable from the above button. # You can also download it directly from the DECIPHER website.  load('/path/to/TrainingSet.RData') trainingSet <- ExTrainList$TrainingSet # Find amino acid sequences corresponding to found genes geneSeqs <- ExtractGenes(genes, dnaGenome, type=\"DNAStringSet\") geneSeqs <- translate(geneSeqs)  # Classify! ids <- IdTaxa(geneSeqs[1:10], trainingSet) # Looking at all results ids ##   A test set of class 'Taxa' with length 10 ##      confidence taxon ##  [1]        99% Root; 09130 Environmental Information Processing; 09132 Signa... ##  [2]       100% Root; 09120 Genetic Information Processing; 09124 Replication... ##  [3]       100% Root; 09120 Genetic Information Processing; 09124 Replication... ##  [4]        28% Root; unclassified_Root...                                       ##  [5]        96% Root; 09180 Brite Hierarchies; 09182 Protein families: geneti... ##  [6]        99% Root; 09180 Brite Hierarchies; 09182 Protein families: geneti... ##  [7]        35% Root; unclassified_Root...                                       ##  [8]        87% Root; unclassified_Root...                                       ##  [9]        29% Root; unclassified_Root...                                       ## [10]        22% Root; unclassified_Root... # Looking at a specific entry ids[[1]] ## $taxon ## [1] \"Root\"                                                    ## [2] \"09130 Environmental Information Processing\"              ## [3] \"09132 Signal transduction\"                               ## [4] \"02020 Two-component system [PATH:ko02020]\"               ## [5] \"K02313  dnaA, chromosomal replication initiator protein\" ##  ## $confidence ## [1] 100 100 100 100 100 # Plot the distribution of results plot(ids, trainingSet)"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/LoadingGenomeData.html","id":"reading-in-sequencing-data","dir":"Articles","previous_headings":"","what":"Reading in Sequencing Data","title":"Loading in Genome Data with DECIPHER","text":"order work sequencing data, first get R format allows us work . commonly used formats genomic data XString XStringSet classes, available Biostrings package. XStrings come 4 distinct flavors, depending characters allowed: DNAString, DNA data (ATGC, plus gaps ambiguity codes) RNAString, RNA data (AUGC, plus gaps ambiguity codes) AAString, amino acid data (20 amino acids plus U, O, ambiguity codes, unknown/gaps) BString, combination letters XString objects type combined, become XStringSet. provides easy way store work genomics data. example manually creating XStringSet: can also translate DNA sequences amino acid counterparts translate(). Manually typing sequences obviously isn’t great system. sequencing data downloadable .fasta .fastq files, let’s look realistic use-case reads data .fasta. ’re going using example set 17 complete Micrococcus genomes obtained NCBI GenBank. ’ve predownloaded repackaged single .FASTA file workshop (file extension .fa.gz since ’s compressed size). See Setup page information download data . sequences trimmed facilitate completing analysis single workshop slot. Feel free experiment complete sequences later. can also build object downloading _genomic.fasta files GenBank reading individually.   Success! Now large example dataset work . wanted visualize sequences, can open web browser using BrowseSeqs() DECIPHER:","code":"library(DECIPHER) # Auto-imports Biostrings sequences <- c('AGACTCGCA',                'AGACGGTCA',                'TCATTAGTT',                'TGCTGAAAA',                'AGCTGTTGC')  sequenceSet <- DNAStringSet(sequences) sequenceSet ## DNAStringSet object of length 5: ##     width seq ## [1]     9 AGACTCGCA ## [2]     9 AGACGGTCA ## [3]     9 TCATTAGTT ## [4]     9 TGCTGAAAA ## [5]     9 AGCTGTTGC translate(sequenceSet) ## AAStringSet object of length 5: ##     width seq ## [1]     3 RLA ## [2]     3 RRS ## [3]     3 SLV ## [4]     3 C*K ## [5]     3 SCC # MicroFASTAtrimmed.fa.gz is loaded from the above button # also available at extdata/LoadingData/ within this package  exampleSeqs <- '/path/to/MicroFASTAtrimmed.fa.gz'  exStringSet <- readDNAStringSet(exampleSeqs, format=\"fasta\") # we could also use format='fastq' for FASTQ datasets BrowseSeqs(exStringSet)"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/LoadingGenomeData.html","id":"aligning-sequences","dir":"Articles","previous_headings":"","what":"Aligning Sequences","title":"Loading in Genome Data with DECIPHER","text":"Now sequences, let’s explore ways can manipulate . complete demo Biostrings outside scope workshop, ’ll just focus functionality added via DECIPHER. common analysis bioinformatics aligning sequences. easily achievable either AlignSeqs() function AlignTranslation() functions DECIPHER. AlignTranslation() aligns sequences based translated amino acid sequences, significantly accurate coding sequences. Alignments tend start lot gaps, result viewing R isn’t always super informative. , can visualize alignment much better way using BrowseSeqs(): output resemble following:","code":"# Align the sequences aliNoTranslate <- AlignSeqs(exStringSet, verbose=FALSE)  # Aligning using translated amino acid sequences aliTranslate <- AlignTranslation(exStringSet, verbose=FALSE)  # Visualize through R  aliNoTranslate ## DNAStringSet object of length 17: ##      width seq                                              names                ##  [1]  3156 ----------------AAATCCC...---------------------- GCF_000023205.1_A... ##  [2]  3156 -----------------------...---------------------- GCF_002008305.4_A... ##  [3]  3156 TAGTGGACGTCACGACCTGCTGT...---------------------- GCF_003691675.1_A... ##  [4]  3156 -----------------------...GTCATCCTCGGTCA-------- GCF_004117015.1_A... ##  [5]  3156 ----------------AAAGTGC...CTCTACCTCCGGGAAGAAACA- GCF_005280335.1_A... ##  ...   ... ... ## [13]  3156 -----------------------...---------------------- GCF_019890915.1_A... ## [14]  3156 -------CCACACCCGAAGGTGT...CTCTACCTCCGGGAAGAAACAC GCF_020097155.1_A... ## [15]  3156 -----------------------...---------------------- GCF_020217385.1_A... ## [16]  3156 -----------------------...---------------------- GCF_023573625.1_A... ## [17]  3156 -----------------------...---------------------- GCF_900475555.1_4... BrowseSeqs(aliNoTranslate)"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/LoadingGenomeData.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Loading in Genome Data with DECIPHER","text":"Now ’ve managed read sequence data perform basic analyses. knowledge, can proceed next step pipeline: finding annotating genes. « 1 2 3 4 5 6 7 »","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Setup.html","id":"setting-up-your-environment","dir":"Articles","previous_headings":"","what":"Setting up your environment","title":"Setup","text":"tutorial depends key packages work correctly. page outline install necessary components workshop. ’re attending tutorial Bioconductor 2022, can skip directly next page.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Setup.html","id":"prerequisites","dir":"Articles","previous_headings":"Setting up your environment","what":"Prerequisites","title":"Setup","text":"content shown using R programming language. existing users, note version R must least version 4.x.x compatibility packages ’ll using. also recommend using RStudio development environment, since ’s excellent IDE tons features. step totally optional; feel free use whatever development environment prefer.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Setup.html","id":"installing-packages","dir":"Articles","previous_headings":"Setting up your environment","what":"Installing packages","title":"Setup","text":"workshop depends two main packages: DECIPHER SynExtend. installed via Bioconductor, package manager open source bioinformatics projects R. tutorials use DECIPHER version 2.25.0 SynExtend version 1.9.4, available development version Bioconductor.","code":"if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\")  #BiocManager::install('DECIPHER', version='2.25.0') #BiocManager::install('SynExtend', version='1.9.4') BiocManager::install('DECIPHER') BiocManager::install('SynExtend')"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/articles/Setup.html","id":"downloading-data","dir":"Articles","previous_headings":"Setting up your environment","what":"Downloading Data","title":"Setup","text":"workshop uses set Micrococcus genomes RefSeq annotations assembly levels Scaffold . data included within package, don’t download able follow along! page also contains download links relevant datafiles. ’d like download data , can find genomic data online NCBI’s Genomes Browser. link relevant query pre-filled. can subset dataset just complete genomes using slider bar shown:  ’ve selected relevant genomes, can download “Download Package” button.  options dialog appears, make sure select “RefSeq ” left, “Genome Sequences (FASTA)” right. can optionally select “Annotation Features (GFF)”, though ’ll also cover create annotations workshop.  , download links relevant data section included, need unless really want .         « 1 2 3 4 5 6 7 »","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aidan Lakshman. Author, maintainer.","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lakshman (2022). CompGenomicsBioc2022: Comparative Genomics Analyses SynExtend DECIPHER. R package version 2.2.0, https://www.ahl27.com/CompGenomicsBioc2022/.","code":"@Manual{,   title = {CompGenomicsBioc2022: Comparative Genomics Analyses with SynExtend and DECIPHER},   author = {Aidan Lakshman},   year = {2022},   note = {R package version 2.2.0},   url = {https://www.ahl27.com/CompGenomicsBioc2022/}, }"},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"using-the-synextend-decipher-pipeline-for-genomic-analysis","dir":"","previous_headings":"","what":"Comparative Genomics with SynExtend and DECIPHER","title":"Comparative Genomics with SynExtend and DECIPHER","text":"SynExtend DECIPHER packages R incorporate wealth easy use functions comparative genomics analyses. interactive tutorial series introduce users packages walking complete workflow identifying co-evolving genes dataset genome sequences. webpage created presentation Bioconductor 2022, content freely available forever. ’ve summarized page skills can expect learn working tutorials site. See Overview page information, along code examples can run ! (Note: ’m still working tutorials. Code currently operational, many toy examples random datasets. final version incorporate consistent dataset entire workshop, well meaningful conclusions. Check Changelog latest updates).","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"topics-covered","dir":"","previous_headings":"","what":"Topics Covered","title":"Comparative Genomics with SynExtend and DECIPHER","text":" ","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"loading-genome-data-with-decipher","dir":"","previous_headings":"Topics Covered","what":"Loading Genome Data with DECIPHER","title":"Comparative Genomics with SynExtend and DECIPHER","text":"first step analyzing genomics data loading data . download sequencing data NCBI .fasta, load R, perform basic operations data. Users learn efficiently work large scale genomics data, including visualization alignment sequencing data. Function Reference","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"gene-calling-and-annotation-with-decipher","dir":"","previous_headings":"Topics Covered","what":"Gene Calling and Annotation with DECIPHER","title":"Comparative Genomics with SynExtend and DECIPHER","text":"natural next step identifying elements comprise genome dataset. Users learn programmatically identify coding non-coding regions genomes, annotate predicted KEGG orthology groups using IDTAXA. Function Reference","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"annotation-of-cogs-with-synextend","dir":"","previous_headings":"Topics Covered","what":"Annotation of COGs with SynExtend","title":"Comparative Genomics with SynExtend and DECIPHER","text":"Annotated genetic regions can mapped across organisms clusters orthologous genes (COGs). Users learn identify COGs scale using data generated previous step. Function Reference","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"constructing-gene-trees-with-decipher","dir":"","previous_headings":"Topics Covered","what":"Constructing Gene Trees with DECIPHER","title":"Comparative Genomics with SynExtend and DECIPHER","text":"COG comprises sets conserved orthologs across species. data, combined sequencing data ortholog, allow us reconstruct evolutionary history COG. Users learn construct, visualize, save phylogenetic trees sets genomes using TreeLine() function. Function Reference","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"identifying-co-evolving-gene-collectives-with-synextend","dir":"","previous_headings":"Topics Covered","what":"Identifying Co-evolving Gene Collectives with SynExtend","title":"Comparative Genomics with SynExtend and DECIPHER","text":"data, can analyze patterns evolutionary signal across COGs. Co-evolutionary signal genes implies functional association, finding COGs shared selective pressure aids us uncovering mechanisms intracellular pathways. Users learn use ProtWeaver class tease subtle evidence correlated evolutionary pressure order create co-evolutionary networks. Function Reference","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"conclusion","dir":"","previous_headings":"Topics Covered","what":"Conclusion","title":"Comparative Genomics with SynExtend and DECIPHER","text":"conclusion workshop, users able perform following tasks R: Visualize sequence data Identify annotate genes sequence data Identify COGs set gene calls Build phylogenies species gene level Predict COGs shared evolutionary pressure","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/index.html","id":"useful-links","dir":"","previous_headings":"Topics Covered","what":"Useful Links","title":"Comparative Genomics with SynExtend and DECIPHER","text":"DECIPHER SynExtend Related Tutorials Lab!          work licensed Creative Commons Attribution-ShareAlike 4.0 International License.","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-2-2-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 2.2.0","text":"Download links fixed IdTaxa training set now download link Images added page","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-2-1-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 2.1.0","text":"ProtWeaver analysis now uses correct dataset Conclusions page updated IdTaxa training set fixed Download links moved page","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"future-work-2-1-0","dir":"Changelog","previous_headings":"","what":"Future Work","title":"Version 2.1.0","text":"download links still missing Conclusions need detail Images missing","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-2-0-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 2.0.0","text":"examples except ProtWeaver analysis use dataset IdTaxa now uses correct training set","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"future-work-2-0-0","dir":"Changelog","previous_headings":"","what":"Future Work","title":"Version 2.0.0","text":"ProtWeaver example updated Conclusions section updated actual takeaways Writeup within section changed reflect new examples Images added","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-1-1-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 1.1.0","text":"Minor updates wording formatting Corrections Gene Calling Annotation page Tutorial section Alignment-Free Analysis removed (readded later figure put )","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-1-0-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 1.0.0","text":"tutorials now complete dataset code!","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"future-work-1-0-0","dir":"Changelog","previous_headings":"","what":"Future Work","title":"Version 1.0.0","text":"Datasets updated prior conference consistency Language/explanations updated May include photo downloading dataset FindingCOGs page","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-0-7-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 0.7.0","text":"Adds download button Setup page datafiles Minor formatting fixes adjustments Examples TreeLine now use correct version","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-0-6-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 0.6.0","text":"Updates GeneCallingAnnotation rough draft code Adds new datafiles use tutorials","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-0-5-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 0.5.0","text":"Updates LoadingGenomeData code Updates ConstructingPhylogenies code Updates CoevolutionNetworks code","code":""},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"known-issues-0-5-0","dir":"Changelog","previous_headings":"","what":"Known Issues","title":"Version 0.5.0","text":"Data used code examples neither consisent final Several tutorials still missing code","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"bugfixes-0-4-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"Version 0.4.0","text":"Updated text support pkgdown automatic reference linking Minor updates README","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-0-3-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 0.3.0","text":"Updated tutorials topics covered final product","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"bugfixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"Version 0.2.0","text":"Changes fix display buttons pagination","code":""},{"path":[]},{"path":"https://www.ahl27.com/CompGenomicsBioc2022/news/index.html","id":"general-notes-0-1-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 0.1.0","text":"Initialization package Creation several empty files mockup final layout","code":""}]
